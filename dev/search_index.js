var documenterSearchIndex = {"docs":
[{"location":"prompts/#MCP-Prompts","page":"Prompts","title":"MCP Prompts","text":"Prompts are template-based messages that language models can use. Each prompt has a name, description, arguments, and message templates.","category":"section"},{"location":"prompts/#Prompt-Structure","page":"Prompts","title":"Prompt Structure","text":"Every prompt in ModelContextProtocol.jl is represented by the MCPPrompt struct:\n\nname: Unique identifier for the prompt\ndescription: Human-readable explanation of the prompt's purpose\narguments: List of parameters the prompt accepts\nmessages: Template messages with placeholders for arguments","category":"section"},{"location":"prompts/#Creating-Prompts","page":"Prompts","title":"Creating Prompts","text":"Here's how to create a basic prompt:\n\nNote: The role field uses the Role enum with values user and assistant. You may need to import these:\n\nimport ModelContextProtocol: user, assistant\n\ngreeting_prompt = MCPPrompt(\n    name = \"greeting\",\n    description = \"Personalized greeting message\",\n    arguments = [\n        PromptArgument(\n            name = \"name\",\n            description = \"User's name\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"time_of_day\",\n            description = \"Morning, afternoon, or evening\",\n            required = false\n        )\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(\n                text = \"Hello! {?time_of_day?Good {time_of_day}}! My name is {name}.\"\n            )\n        )\n    ]\n)","category":"section"},{"location":"prompts/#Arguments","page":"Prompts","title":"Arguments","text":"Prompt arguments are defined using the PromptArgument struct:\n\nname: Parameter identifier\ndescription: Explanation of the parameter\nrequired: Whether the argument must be provided (default: false)","category":"section"},{"location":"prompts/#Template-Syntax","page":"Prompts","title":"Template Syntax","text":"Prompt templates support parameter substitution and conditional blocks:\n\nBasic substitution: {parameter_name}\nConditional blocks: {?parameter_name?content if parameter exists}","category":"section"},{"location":"prompts/#Registering-Prompts","page":"Prompts","title":"Registering Prompts","text":"Prompts can be registered with a server in two ways:\n\nDuring server creation:\n\nserver = mcp_server(\n    name = \"my-server\",\n    prompts = my_prompt  # Single prompt or vector of prompts\n)\n\nAfter server creation:\n\nregister!(server, my_prompt)","category":"section"},{"location":"prompts/#Directory-Based-Organization","page":"Prompts","title":"Directory-Based Organization","text":"Prompts can be organized in directory structures and auto-registered:\n\nmy_server/\n└── prompts/\n    ├── greeting.jl\n    └── faq.jl\n\nEach file should export one or more MCPPrompt instances:\n\n# greeting.jl\nusing ModelContextProtocol\n\ngreeting_prompt = MCPPrompt(\n    name = \"greeting\",\n    description = \"Personalized greeting message\",\n    arguments = [\n        PromptArgument(name = \"name\", description = \"User's name\", required = true)\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(text = \"Hello! My name is {name}.\")\n        )\n    ]\n)\n\nThen auto-register from the directory:\n\nserver = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"section"},{"location":"prompts/#Advanced-Examples","page":"Prompts","title":"Advanced Examples","text":"","category":"section"},{"location":"prompts/#Multi-Message-Conversation-Prompt","page":"Prompts","title":"Multi-Message Conversation Prompt","text":"conversation_prompt = MCPPrompt(\n    name = \"code_review\",\n    description = \"Code review conversation template\",\n    arguments = [\n        PromptArgument(\n            name = \"language\",\n            description = \"Programming language\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"code\",\n            description = \"Code to review\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"focus_area\",\n            description = \"Specific area to focus on\",\n            required = false\n        )\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(\n                text = \"Please review this {language} code:{?focus_area? Focus on {focus_area}.}\"\n            )\n        ),\n        PromptMessage(\n            role = user,\n            content = TextContent(text = \"```{language}\\n{code}\\n```\")\n        ),\n        PromptMessage(\n            role = assistant,\n            content = TextContent(\n                text = \"I'll analyze this {language} code{?focus_area? with focus on {focus_area}}.\"\n            )\n        )\n    ]\n)","category":"section"},{"location":"prompts/#Prompt-with-Image-Content","page":"Prompts","title":"Prompt with Image Content","text":"visual_prompt = MCPPrompt(\n    name = \"analyze_diagram\",\n    description = \"Analyze a diagram or chart\",\n    arguments = [\n        PromptArgument(name = \"image_path\", description = \"Path to image\", required = true),\n        PromptArgument(name = \"question\", description = \"Question about the image\", required = false)\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(\n                text = \"Please analyze this diagram{?question?: {question}}\"\n            )\n        ),\n        # Note: In practice, you'd load the actual image data\n        PromptMessage(\n            role = user,\n            content = ImageContent(\n                data = UInt8[],  # Placeholder for image bytes\n                mime_type = \"image/png\"\n            )\n        )\n    ]\n)","category":"section"},{"location":"resources/#MCP-Resources","page":"Resources","title":"MCP Resources","text":"Resources provide data that language models can access. Each resource has a URI, name, MIME type, and a data provider function.","category":"section"},{"location":"resources/#Resource-Structure","page":"Resources","title":"Resource Structure","text":"Every resource in ModelContextProtocol.jl is represented by the MCPResource struct:\n\nuri: Unique URI identifier for the resource\nname: Human-readable resource name\ndescription: Explanation of the resource's purpose\nmime_type: Content type (e.g., \"application/json\", \"text/plain\")\ndata_provider: Function that returns the resource's data\nannotations: Optional metadata about the resource","category":"section"},{"location":"resources/#Creating-Resources","page":"Resources","title":"Creating Resources","text":"Here's how to create a basic resource:\n\nusing URIs\n\nweather_resource = MCPResource(\n    uri = \"weather://current\",\n    name = \"Current Weather\",\n    description = \"Current weather conditions\",\n    mime_type = \"application/json\",\n    data_provider = () -> Dict(\n        \"temperature\" => 22.5,\n        \"conditions\" => \"Partly Cloudy\",\n        \"updated\" => Dates.format(now(), \"yyyy-mm-dd HH:MM:SS\")\n    )\n)\n\nNote: The uri field accepts both strings and URI objects. Strings are automatically converted to URIs.","category":"section"},{"location":"resources/#Data-Providers","page":"Resources","title":"Data Providers","text":"The data_provider function can return different types of data:\n\nFor simple data (automatically serialized to JSON):\nReturn Julia objects (Dict, Array, etc.) that can be JSON-serialized\nThese are wrapped in TextResourceContents with JSON serialization\nFor explicit control over content:\nReturn TextResourceContents for text data\nReturn BlobResourceContents for binary data\n\nThe data_provider receives the requested URI as a parameter when using wildcards.","category":"section"},{"location":"resources/#Registering-Resources","page":"Resources","title":"Registering Resources","text":"Resources can be registered with a server in two ways:\n\nDuring server creation:\n\nserver = mcp_server(\n    name = \"my-server\",\n    resources = my_resource  # Single resource or vector of resources\n)\n\nAfter server creation:\n\nregister!(server, my_resource)","category":"section"},{"location":"resources/#Directory-Based-Organization","page":"Resources","title":"Directory-Based Organization","text":"Resources can be organized in directory structures and auto-registered:\n\nmy_server/\n└── resources/\n    ├── weather.jl\n    └── stock_data.jl\n\nEach file should export one or more MCPResource instances:\n\n# weather.jl\nusing ModelContextProtocol\nusing Dates\n\nweather_resource = MCPResource(\n    uri = \"weather://current\",\n    name = \"Current Weather\",\n    description = \"Current weather conditions\",\n    mime_type = \"application/json\",\n    data_provider = () -> Dict(\n        \"temperature\" => 22.5,\n        \"conditions\" => \"Partly Cloudy\",\n        \"updated\" => Dates.format(now(), \"yyyy-mm-dd HH:MM:SS\")\n    )\n)\n\nThen auto-register from the directory:\n\nserver = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"section"},{"location":"resources/#Advanced-Examples","page":"Resources","title":"Advanced Examples","text":"","category":"section"},{"location":"resources/#Resource-with-Dynamic-URI-Patterns","page":"Resources","title":"Resource with Dynamic URI Patterns","text":"# Support URIs like file://path/to/file.txt\nfile_resource = MCPResource(\n    uri = \"file://*\",\n    name = \"File System Access\",\n    description = \"Access local files\",\n    mime_type = \"text/plain\",\n    data_provider = function(uri::String)\n        # Extract path from URI\n        path = replace(uri, \"file://\" => \"\")\n        \n        if isfile(path)\n            content = read(path, String)\n            return TextResourceContents(\n                uri = uri,\n                text = content,\n                mime_type = \"text/plain\"\n            )\n        else\n            error(\"File not found: $path\")\n        end\n    end\n)","category":"section"},{"location":"resources/#Resource-with-Binary-Data","page":"Resources","title":"Resource with Binary Data","text":"image_resource = MCPResource(\n    uri = \"images://logo\",\n    name = \"Logo Image\",\n    description = \"Company logo\",\n    mime_type = \"image/png\",\n    data_provider = function(uri::String)\n        image_data = read(\"logo.png\")  # Returns Vector{UInt8}\n        return BlobResourceContents(\n            uri = uri,\n            blob = image_data,\n            mime_type = \"image/png\"\n        )\n    end\n)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#Primary-Interface","page":"API Reference","title":"Primary Interface","text":"","category":"section"},{"location":"api/#Server-Operations","page":"API Reference","title":"Server Operations","text":"","category":"section"},{"location":"api/#Component-Types","page":"API Reference","title":"Component Types","text":"","category":"section"},{"location":"api/#Tools","page":"API Reference","title":"Tools","text":"","category":"section"},{"location":"api/#Resources","page":"API Reference","title":"Resources","text":"","category":"section"},{"location":"api/#Prompts","page":"API Reference","title":"Prompts","text":"","category":"section"},{"location":"api/#Content-Types","page":"API Reference","title":"Content Types","text":"","category":"section"},{"location":"api/#Abstract-Types","page":"API Reference","title":"Abstract Types","text":"","category":"section"},{"location":"api/#Concrete-Content-Types","page":"API Reference","title":"Concrete Content Types","text":"note: ResourceLink\nResourceLink is part of the 2025-06-18 protocol but not yet exported. It will be available in a future release.","category":"section"},{"location":"api/#Resource-Content-Types","page":"API Reference","title":"Resource Content Types","text":"","category":"section"},{"location":"api/#Tool-Results","page":"API Reference","title":"Tool Results","text":"","category":"section"},{"location":"api/#Transport-Configuration","page":"API Reference","title":"Transport Configuration","text":"note: Transport Types\nTransport types (StdioTransport, HttpTransport) are internal implementation details and are not exported. Use mcp_server with appropriate options to configure transport.","category":"section"},{"location":"api/#Server-Type","page":"API Reference","title":"Server Type","text":"","category":"section"},{"location":"api/#Resource-Subscriptions","page":"API Reference","title":"Resource Subscriptions","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#Transport-Options","page":"API Reference","title":"Transport Options","text":"ModelContextProtocol.jl supports multiple transport mechanisms:","category":"section"},{"location":"api/#STDIO-Transport-(Default)","page":"API Reference","title":"STDIO Transport (Default)","text":"server = mcp_server(name = \"my-server\")\nstart!(server)  # Uses StdioTransport by default","category":"section"},{"location":"api/#HTTP-Transport","page":"API Reference","title":"HTTP Transport","text":"server = mcp_server(name = \"my-http-server\")\nstart!(server; transport = HttpTransport(; port = 3000))\n\n# With custom configuration\nstart!(server; transport = HttpTransport(;\n    host = \"127.0.0.1\",  # Important for Windows\n    port = 8080,         # Default port\n    endpoint = \"/\"       # Default endpoint\n))\n\nNote: HTTP transport currently supports HTTP only, not HTTPS. For production use:\n\nUse mcp-remote with --allow-http flag for secure connections\nOr deploy behind a reverse proxy (nginx, Apache) for TLS termination","category":"section"},{"location":"api/#All-Exported-Symbols","page":"API Reference","title":"All Exported Symbols","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#Constants","page":"API Reference","title":"Constants","text":"","category":"section"},{"location":"api/#Macros","page":"API Reference","title":"Macros","text":"","category":"section"},{"location":"api/#Internal-API","page":"API Reference","title":"Internal API","text":"The following internal types and functions are documented for developers working on the package itself.","category":"section"},{"location":"api/#Protocol-Types","page":"API Reference","title":"Protocol Types","text":"","category":"section"},{"location":"api/#Core-Implementation","page":"API Reference","title":"Core Implementation","text":"","category":"section"},{"location":"api/#Transport-Implementation","page":"API Reference","title":"Transport Implementation","text":"","category":"section"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#ModelContextProtocol.mcp_server","page":"API Reference","title":"ModelContextProtocol.mcp_server","text":"mcp_server(; name::String, version::String=\"1.0.0\", \n         tools::Union{Vector{MCPTool},MCPTool,Nothing}=nothing,\n         resources::Union{Vector{MCPResource},MCPResource,Nothing}=nothing, \n         prompts::Union{Vector{MCPPrompt},MCPPrompt,Nothing}=nothing,\n         description::String=\"\", \n         capabilities::Vector{Capability}=default_capabilities(),\n         auto_register_dir::Union{String,Nothing}=nothing) -> Server\n\nPrimary entry point for creating and configuring a Model Context Protocol (MCP) server.\n\nArguments\n\nname::String: Unique identifier for the server instance \nversion::String: Your server implementation version (defaults to \"1.0.0\") - YOUR server's version, not the MCP protocol version\ntools: Tools to expose to the model\nresources: Resources available to the model\nprompts: Predefined prompts for the model\ndescription::String: Optional server description\ncapabilities::Vector{Capability}: Server capability configuration\nauto_register_dir: Directory to auto-register components from\n\nReturns\n\nServer: A configured server instance ready to handle MCP client connections\n\nExample\n\nserver = mcp_server(\n    name = \"my-server\",\n    version = \"1.0.0\",  # Your server version\n    description = \"Demo server with time tool\",\n    tools = MCPTool(\n        name = \"get_time\",\n        description = \"Get current time\",\n        parameters = [],\n        handler = args -> Dates.format(now(), \"HH:MM:SS\")\n    )\n)\nstart!(server)\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.start!","page":"API Reference","title":"ModelContextProtocol.start!","text":"start!(server::Server; transport::Union{Transport,Nothing}=nothing) -> Nothing\n\nStart the MCP server, setting up logging and entering the main server loop.\n\nArguments\n\nserver::Server: The server instance to start\ntransport::Union{Transport,Nothing}: Optional transport to use. If not provided, uses StdioTransport\n\nReturns\n\nNothing: The function returns after the server stops\n\nThrows\n\nServerError: If the server is already running\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.stop!","page":"API Reference","title":"ModelContextProtocol.stop!","text":"stop!(server::Server) -> Nothing\n\nStop a running MCP server.\n\nArguments\n\nserver::Server: The server instance to stop\n\nReturns\n\nNothing: The function returns after setting the server to inactive\n\nThrows\n\nServerError: If the server is not currently running\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.register!","page":"API Reference","title":"ModelContextProtocol.register!","text":"register!(server::Server, component::Union{Tool,Resource,MCPPrompt}) -> Server\n\nRegister a tool, resource, or prompt with the MCP server.\n\nArguments\n\nserver::Server: The server to register the component with\ncomponent: The component to register (can be a tool, resource, or prompt)\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.MCPTool","page":"API Reference","title":"ModelContextProtocol.MCPTool","text":"MCPTool(; name::String, description::String, parameters::Vector{ToolParameter},\n      handler::Function, return_type::Type=Vector{Content}) <: Tool\n\nImplement a tool that can be invoked by clients in the MCP protocol.\n\nFields\n\nname::String: Unique identifier for the tool\ndescription::String: Human-readable description of the tool's purpose\nparameters::Vector{ToolParameter}: Parameters that the tool accepts\nhandler::Function: Function that implements the tool's functionality\nreturn_type::Type: Expected return type of the handler (defaults to Vector{Content})\n\nHandler Return Types\n\nThe tool handler can return various types which are automatically converted:\n\nAn instance of the specified Content type (TextContent, ImageContent, etc.)\nA Vector{<:Content} for multiple content items (can mix TextContent, ImageContent, etc.)\nA Dict (automatically converted to JSON and wrapped in TextContent)\nA String (automatically wrapped in TextContent)\nA Tuple{Vector{UInt8}, String} (automatically wrapped in ImageContent)\nA CallToolResult object for full control over the response (including error handling)\n\nWhen returntype is Vector{Content} (default), single Content items are automatically wrapped in a vector. Note: When returning CallToolResult directly, the returntype field is ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ToolParameter","page":"API Reference","title":"ModelContextProtocol.ToolParameter","text":"ToolParameter(; name::String, description::String, type::String, required::Bool=false, default::Any=nothing)\n\nDefine a parameter for an MCP tool.\n\nFields\n\nname::String: The parameter name (used as the key in the params dictionary)\ndescription::String: Human-readable description of the parameter\ntype::String: Type of the parameter as specified in the MCP schema (e.g., \"string\", \"number\", \"boolean\")\nrequired::Bool: Whether the parameter is required for tool invocation\ndefault::Any: Default value for the parameter if not provided (nothing means no default)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPResource","page":"API Reference","title":"ModelContextProtocol.MCPResource","text":"MCPResource <: Resource\n\nImplement a resource that clients can access in the MCP protocol. Resources represent data that can be read by models and tools.\n\nFields\n\nuri::URI: Unique identifier for the resource\nname::String: Human-readable name for the resource\ndescription::String: Detailed description of the resource\nmime_type::String: MIME type of the resource data\ndata_provider::Function: Function that provides the resource data when called\nannotations::AbstractDict{String,Any}: Additional metadata for the resource\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceTemplate","page":"API Reference","title":"ModelContextProtocol.ResourceTemplate","text":"ResourceTemplate(; name::String, uri_template::String,\n               mime_type::Union{String,Nothing}=nothing, description::String=\"\")\n\nDefine a template for dynamically generating resources with parameterized URIs.\n\nFields\n\nname::String: Name of the resource template\nuri_template::String: Template string with placeholders for parameters\nmime_type::Union{String,Nothing}: MIME type of the generated resources\ndescription::String: Human-readable description of the template\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPPrompt","page":"API Reference","title":"ModelContextProtocol.MCPPrompt","text":"MCPPrompt(; name::String, description::String=\"\", \n        arguments::Vector{PromptArgument}=PromptArgument[], \n        messages::Vector{PromptMessage}=PromptMessage[])\n\nImplement a prompt or prompt template as defined in the MCP schema. Prompts can include variables that are replaced with arguments when retrieved.\n\nFields\n\nname::String: Unique identifier for the prompt\ndescription::String: Human-readable description of the prompt's purpose\narguments::Vector{PromptArgument}: Arguments that this prompt accepts\nmessages::Vector{PromptMessage}: The sequence of messages in the prompt\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptArgument","page":"API Reference","title":"ModelContextProtocol.PromptArgument","text":"PromptArgument(; name::String, description::String=\"\", required::Bool=false)\n\nDefine an argument that a prompt template can accept.\n\nFields\n\nname::String: The argument name (used in template placeholders)\ndescription::String: Human-readable description of the argument\nrequired::Bool: Whether the argument is required when using the prompt\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptMessage","page":"API Reference","title":"ModelContextProtocol.PromptMessage","text":"PromptMessage(; content::Union{TextContent, ImageContent, EmbeddedResource}, role::Role=user)\n\nRepresent a single message in a prompt template.\n\nFields\n\ncontent::Union{TextContent, ImageContent, EmbeddedResource}: The content of the message\nrole::Role: Whether this message is from the user or assistant (defaults to user)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Content","page":"API Reference","title":"ModelContextProtocol.Content","text":"Content\n\nAbstract base type for all content formats in the MCP protocol. Content can be exchanged between clients and servers in various formats.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceContents","page":"API Reference","title":"ModelContextProtocol.ResourceContents","text":"ResourceContents\n\nAbstract base type for resource content formats in the MCP protocol. Resources can contain different types of content based on their MIME type.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.TextContent","page":"API Reference","title":"ModelContextProtocol.TextContent","text":"TextContent(; type::String=\"text\", text::String, \n            annotations::Union{Nothing,Dict{String,Any}}=nothing,\n            _meta::Union{Nothing,Dict{String,Any}}=nothing) <: Content\n\nText-based content for messages and tool responses.\n\nFields\n\ntype::String: Content type identifier (always \"text\")\ntext::String: The actual text content\nannotations::Union{Nothing,Dict{String,Any}}: Optional annotations for the client\n_meta::Union{Nothing,Dict{String,Any}}: Optional metadata for protocol extensions\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ImageContent","page":"API Reference","title":"ModelContextProtocol.ImageContent","text":"ImageContent(; type::String=\"image\", data::Vector{UInt8}, mime_type::String,\n             annotations::Union{Nothing,Dict{String,Any}}=nothing,\n             _meta::Union{Nothing,Dict{String,Any}}=nothing) <: Content\n\nImage content for messages and tool responses.\n\nFields\n\ntype::String: Content type identifier (always \"image\")\ndata::Vector{UInt8}: Raw image data (automatically base64-encoded when serialized)\nmime_type::String: MIME type of the image (e.g., \"image/png\")\nannotations::Union{Nothing,Dict{String,Any}}: Optional annotations for the client\n_meta::Union{Nothing,Dict{String,Any}}: Optional metadata for protocol extensions\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.EmbeddedResource","page":"API Reference","title":"ModelContextProtocol.EmbeddedResource","text":"EmbeddedResource(; type::String=\"resource\", resource::Dict{String,Any},\n                 annotations::Union{Nothing,Dict{String,Any}}=nothing,\n                 _meta::Union{Nothing,Dict{String,Any}}=nothing) <: Content\n\nEmbedded resource content for inline resource data.\n\nFields\n\ntype::String: Content type identifier (always \"resource\")\nresource::Dict{String,Any}: The embedded resource data\nannotations::Union{Nothing,Dict{String,Any}}: Optional annotations for the client\n_meta::Union{Nothing,Dict{String,Any}}: Optional metadata for protocol extensions\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.TextResourceContents","page":"API Reference","title":"ModelContextProtocol.TextResourceContents","text":"TextResourceContents(; uri::URI, mime_type::String=\"text/plain\", text::String) <: ResourceContents\n\nText content for resources in the MCP protocol.\n\nFields\n\nuri::URI: Resource identifier\nmime_type::String: MIME type of the text content\ntext::String: The actual text content\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.BlobResourceContents","page":"API Reference","title":"ModelContextProtocol.BlobResourceContents","text":"BlobResourceContents(; uri::URI, mime_type::String=\"application/octet-stream\", \n                    blob::Vector{UInt8}) <: ResourceContents\n\nBinary content for resources.\n\nFields\n\nuri::URI: Resource identifier\nmime_type::String: MIME type of the binary content\nblob::Vector{UInt8}: Raw binary data (automatically base64-encoded when serialized)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.CallToolResult","page":"API Reference","title":"ModelContextProtocol.CallToolResult","text":"CallToolResult(; content::Vector{Dict{String,Any}}, is_error::Bool=false) <: ResponseResult\n\nResult returned from a tool invocation.\n\nFields\n\ncontent::Vector{Dict{String,Any}}: Content produced by the tool\nis_error::Bool: Whether the tool execution resulted in an error\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Server","page":"API Reference","title":"ModelContextProtocol.Server","text":"Server(config::ServerConfig; transport::Union{Transport,Nothing}=nothing)\n\nRepresent a running MCP server instance that manages resources, tools, and prompts.\n\nFields\n\nconfig::ServerConfig: Server configuration settings\ntransport::Union{Transport,Nothing}: Transport implementation for client-server communication\nresources::Vector{Resource}: Available resources\ntools::Vector{Tool}: Available tools\nprompts::Vector{MCPPrompt}: Available prompts\nresource_templates::Vector{ResourceTemplate}: Available resource templates\nsubscriptions::DefaultDict{String,Vector{Subscription}}: Resource subscription registry\nprogress_trackers::Dict{Union{String,Int},Progress}: Progress tracking for operations\nactive::Bool: Whether the server is currently active\n\nConstructor\n\nServer(config::ServerConfig; transport=nothing): Creates a new server with the specified configuration\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.subscribe!","page":"API Reference","title":"ModelContextProtocol.subscribe!","text":"subscribe!(server::Server, uri::String, callback::Function) -> Server\n\nSubscribe to updates for a specific resource identified by URI.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to subscribe to\ncallback::Function: The function to call when the resource is updated\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.unsubscribe!","page":"API Reference","title":"ModelContextProtocol.unsubscribe!","text":"unsubscribe!(server::Server, uri::String, callback::Function) -> Server\n\nRemove a subscription for a specific resource URI and callback function.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to unsubscribe from\ncallback::Function: The callback function to remove\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.content2dict","page":"API Reference","title":"ModelContextProtocol.content2dict","text":"content2dict(content::Content) -> Dict{String,Any}\n\nConvert a Content object to its dictionary representation for JSON serialization.\n\nArguments\n\ncontent::Content: The content object to convert\n\nReturns\n\nDict{String,Any}: Dictionary representation of the content\n\nExamples\n\ntext_content = TextContent(text=\"Hello\", type=\"text\")\ndict = content2dict(text_content)\n# Returns: Dict(\"type\" => \"text\", \"text\" => \"Hello\", \"annotations\" => Dict())\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.HttpTransport","page":"API Reference","title":"ModelContextProtocol.HttpTransport","text":"HttpTransport(; host::String=\"127.0.0.1\", port::Int=8080, endpoint::String=\"/\")\n\nTransport implementation following the MCP Streamable HTTP specification (2025-06-18). Supports Server-Sent Events (SSE) for streaming and session management.\n\nFields\n\nhost::String: Host address to bind to (default: \"127.0.0.1\")\nport::Int: Port number to listen on (default: 8080)\nendpoint::String: HTTP endpoint path (default: \"/\")\nserver::Union{HTTP.Server,Nothing}: HTTP server instance\nconnected::Bool: Connection status\nserver_task::Union{Task,Nothing}: Server task handle\nactive_streams::Dict{String,HTTP.Stream}: Active streaming connections\nrequest_queue::Channel{Tuple{String,String}}: Queue for incoming requests (id, message)\nresponse_channels::Dict{String,Channel{String}}: Response channels per request\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPPrompt-Tuple{String, String, Vector{PromptArgument}, String}","page":"API Reference","title":"ModelContextProtocol.MCPPrompt","text":"MCPPrompt(name::String, description::String, arguments::Vector{PromptArgument}, text::String) -> MCPPrompt\n\nCreate a prompt with a single text message.\n\nArguments\n\nname::String: Unique identifier for the prompt\ndescription::String: Human-readable description\narguments::Vector{PromptArgument}: Arguments the prompt accepts\ntext::String: Text content for the prompt message\n\nReturns\n\nMCPPrompt: A new prompt with a single user message containing the text\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.MCPResource-Tuple{}","page":"API Reference","title":"ModelContextProtocol.MCPResource","text":"MCPResource(; uri, name::String=\"\", description::String=\"\",\n          mime_type::String=\"application/json\", data_provider::Function,\n          annotations::AbstractDict{String,Any}=LittleDict{String,Any}()) -> MCPResource\n\nCreate a resource with automatic URI conversion from strings or URIs.\n\nArguments\n\nuri: String or URI identifier for the resource\nname::String: Human-readable name for the resource\ndescription::String: Detailed description\nmime_type::String: MIME type of the resource\ndata_provider::Function: Function that returns the resource data when called\nannotations::AbstractDict{String,Any}: Additional metadata for the resource\n\nReturns\n\nMCPResource: A new resource with the provided configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.PromptMessage-Tuple{Union{EmbeddedResource, ImageContent, TextContent}}","page":"API Reference","title":"ModelContextProtocol.PromptMessage","text":"PromptMessage(content::Union{TextContent, ImageContent, EmbeddedResource}) -> PromptMessage\n\nCreate a prompt message with only content (role defaults to user).\n\nArguments\n\ncontent::Union{TextContent, ImageContent, EmbeddedResource}: The message content\n\nReturns\n\nPromptMessage: A new prompt message with the default user role\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.ResourceLink","page":"API Reference","title":"ModelContextProtocol.ResourceLink","text":"ResourceLink(; type::String=\"link\", href::String, \n             title::Union{String,Nothing}=nothing,\n             annotations::Union{Nothing,Dict{String,Any}}=nothing,\n             _meta::Union{Nothing,Dict{String,Any}}=nothing) <: Content\n\nLink to an external resource (NEW in protocol 2025-06-18).\n\nFields\n\ntype::String: Content type identifier (always \"link\")\nhref::String: URL or URI of the linked resource\ntitle::Union{String,Nothing}: Optional human-readable title for the link\nannotations::Union{Nothing,Dict{String,Any}}: Optional annotations for the client\n_meta::Union{Nothing,Dict{String,Any}}: Optional metadata for protocol extensions\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.StdioTransport","page":"API Reference","title":"ModelContextProtocol.StdioTransport","text":"StdioTransport(; input::IO=stdin, output::IO=stdout)\n\nTransport implementation using standard input/output streams. This is the default transport for local MCP server processes.\n\nFields\n\ninput::IO: Input stream for reading messages (default: stdin)\noutput::IO: Output stream for writing messages (default: stdout)  \nconnected::Bool: Connection status (always true for stdio)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Transport","page":"API Reference","title":"ModelContextProtocol.Transport","text":"Transport\n\nAbstract base type for all MCP transport implementations. Defines the interface for reading and writing messages between client and server.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.connect-Tuple{HttpTransport}","page":"API Reference","title":"ModelContextProtocol.connect","text":"connect(transport::HttpTransport) -> Nothing\n\nStart the HTTP server and begin listening for connections.\n\nArguments\n\ntransport::HttpTransport: The transport instance\n\nReturns\n\nNothing\n\nThrows\n\nTransportError: If the server cannot be started\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.connect-Tuple{Transport}","page":"API Reference","title":"ModelContextProtocol.connect","text":"connect(transport::Transport) -> Nothing\n\nEstablish the transport connection. Default implementation does nothing (for transports that are always connected).\n\nArguments\n\ntransport::Transport: The transport instance to connect\n\nReturns\n\nNothing\n\nThrows\n\nTransportError: If connection cannot be established\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.mcp_server-Tuple{}","page":"API Reference","title":"ModelContextProtocol.mcp_server","text":"mcp_server(; name::String, version::String=\"1.0.0\", \n         tools::Union{Vector{MCPTool},MCPTool,Nothing}=nothing,\n         resources::Union{Vector{MCPResource},MCPResource,Nothing}=nothing, \n         prompts::Union{Vector{MCPPrompt},MCPPrompt,Nothing}=nothing,\n         description::String=\"\", \n         capabilities::Vector{Capability}=default_capabilities(),\n         auto_register_dir::Union{String,Nothing}=nothing) -> Server\n\nPrimary entry point for creating and configuring a Model Context Protocol (MCP) server.\n\nArguments\n\nname::String: Unique identifier for the server instance \nversion::String: Your server implementation version (defaults to \"1.0.0\") - YOUR server's version, not the MCP protocol version\ntools: Tools to expose to the model\nresources: Resources available to the model\nprompts: Predefined prompts for the model\ndescription::String: Optional server description\ncapabilities::Vector{Capability}: Server capability configuration\nauto_register_dir: Directory to auto-register components from\n\nReturns\n\nServer: A configured server instance ready to handle MCP client connections\n\nExample\n\nserver = mcp_server(\n    name = \"my-server\",\n    version = \"1.0.0\",  # Your server version\n    description = \"Demo server with time tool\",\n    tools = MCPTool(\n        name = \"get_time\",\n        description = \"Get current time\",\n        parameters = [],\n        handler = args -> Dates.format(now(), \"HH:MM:SS\")\n    )\n)\nstart!(server)\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.start!-Tuple{Server}","page":"API Reference","title":"ModelContextProtocol.start!","text":"start!(server::Server; transport::Union{Transport,Nothing}=nothing) -> Nothing\n\nStart the MCP server, setting up logging and entering the main server loop.\n\nArguments\n\nserver::Server: The server instance to start\ntransport::Union{Transport,Nothing}: Optional transport to use. If not provided, uses StdioTransport\n\nReturns\n\nNothing: The function returns after the server stops\n\nThrows\n\nServerError: If the server is already running\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.stop!-Tuple{Server}","page":"API Reference","title":"ModelContextProtocol.stop!","text":"stop!(server::Server) -> Nothing\n\nStop a running MCP server.\n\nArguments\n\nserver::Server: The server instance to stop\n\nReturns\n\nNothing: The function returns after setting the server to inactive\n\nThrows\n\nServerError: If the server is not currently running\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.subscribe!-Tuple{Server, String, Function}","page":"API Reference","title":"ModelContextProtocol.subscribe!","text":"subscribe!(server::Server, uri::String, callback::Function) -> Server\n\nSubscribe to updates for a specific resource identified by URI.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to subscribe to\ncallback::Function: The function to call when the resource is updated\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.unsubscribe!-Tuple{Server, String, Function}","page":"API Reference","title":"ModelContextProtocol.unsubscribe!","text":"unsubscribe!(server::Server, uri::String, callback::Function) -> Server\n\nRemove a subscription for a specific resource URI and callback function.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to unsubscribe from\ncallback::Function: The callback function to remove\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.CallToolParams","page":"API Reference","title":"ModelContextProtocol.CallToolParams","text":"CallToolParams(; name::String, arguments::Union{Dict{String,Any},Nothing}=nothing) <: RequestParams\n\nParameters for invoking a specific tool on an MCP server.\n\nFields\n\nname::String: Name of the tool to call\narguments::Union{Dict{String,Any},Nothing}: Optional arguments to pass to the tool\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ClientCapabilities","page":"API Reference","title":"ModelContextProtocol.ClientCapabilities","text":"ClientCapabilities(; experimental::Union{Dict{String,Dict{String,Any}},Nothing}=nothing,\n                roots::Union{Dict{String,Bool},Nothing}=nothing,\n                sampling::Union{Dict{String,Any},Nothing}=nothing)\n\nCapabilities reported by an MCP client during initialization.\n\nFields\n\nexperimental::Union{Dict{String,Dict{String,Any}},Nothing}: Experimental features supported\nroots::Union{Dict{String,Bool},Nothing}: Root directories client has access to\nsampling::Union{Dict{String,Any},Nothing}: Sampling capabilities for model generation\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ErrorInfo","page":"API Reference","title":"ModelContextProtocol.ErrorInfo","text":"ErrorInfo(; code::Int, message::String, data::Union{Dict{String,Any},Nothing}=nothing)\n\nError information structure for JSON-RPC error responses.\n\nFields\n\ncode::Int: Numeric error code (predefined in ErrorCodes module)\nmessage::String: Human-readable error description\ndata::Union{Dict{String,Any},Nothing}: Optional additional error details\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.GetPromptParams","page":"API Reference","title":"ModelContextProtocol.GetPromptParams","text":"GetPromptParams(; name::String, arguments::Union{Dict{String,String},Nothing}=nothing) <: RequestParams\n\nParameters for requesting a specific prompt from an MCP server.\n\nFields\n\nname::String: Name of the prompt to retrieve\narguments::Union{Dict{String,String},Nothing}: Optional arguments to apply to the prompt template\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.GetPromptResult","page":"API Reference","title":"ModelContextProtocol.GetPromptResult","text":"GetPromptResult(; description::String, messages::Vector{PromptMessage}) <: ResponseResult\n\nResult returned from a get prompt request.\n\nFields\n\ndescription::String: Description of the prompt\nmessages::Vector{PromptMessage}: The prompt messages with template variables replaced\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Implementation","page":"API Reference","title":"ModelContextProtocol.Implementation","text":"Implementation(; name::String=\"default-client\", version::String=\"1.0.0\")\n\nInformation about a client or server implementation of the MCP protocol.\n\nFields\n\nname::String: Name of the implementation\nversion::String: Version string of the implementation\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.InitializeParams","page":"API Reference","title":"ModelContextProtocol.InitializeParams","text":"InitializeParams(; capabilities::ClientCapabilities=ClientCapabilities(),\n               clientInfo::Implementation=Implementation(),\n               protocolVersion::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for MCP protocol initialization requests.\n\nFields\n\ncapabilities::ClientCapabilities: Client capabilities being reported\nclientInfo::Implementation: Information about the client implementation  \nprotocolVersion::Union{String,Nothing}: Version of the MCP protocol being used (must be \"2025-06-18\" - only supported version)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.InitializeResult","page":"API Reference","title":"ModelContextProtocol.InitializeResult","text":"InitializeResult(; serverInfo::Dict{String,Any}, capabilities::Dict{String,Any},\n               protocolVersion::String, instructions::String=\"\") <: ResponseResult\n\nResult returned in response to MCP protocol initialization.\n\nFields\n\nserverInfo::Dict{String,Any}: Information about the server implementation\ncapabilities::Dict{String,Any}: Server capabilities being reported\nprotocolVersion::String: Version of the MCP protocol being used\ninstructions::String: Optional usage instructions for clients\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCError","page":"API Reference","title":"ModelContextProtocol.JSONRPCError","text":"JSONRPCError(; id::Union{RequestId,Nothing}, error::ErrorInfo) <: Response\n\nJSON-RPC error response message returned when requests fail.\n\nFields\n\nid::Union{RequestId,Nothing}: Identifier matching the request this is responding to, or null\nerror::ErrorInfo: Information about the error that occurred\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCNotification","page":"API Reference","title":"ModelContextProtocol.JSONRPCNotification","text":"JSONRPCNotification(; method::String, \n                   params::Union{RequestParams,Dict{String,Any}}) <: Notification\n\nJSON-RPC notification message that does not expect a response.\n\nFields\n\nmethod::String: Name of the notification method\nparams::Union{RequestParams,Dict{String,Any}}: Parameters for the notification\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCRequest","page":"API Reference","title":"ModelContextProtocol.JSONRPCRequest","text":"JSONRPCRequest(; id::RequestId, method::String, \n             params::Union{RequestParams, Nothing}, \n             meta::RequestMeta=RequestMeta()) <: Request\n\nJSON-RPC request message used to invoke methods on the server.\n\nFields\n\nid::RequestId: Unique identifier for the request\nmethod::String: Name of the method to invoke\nparams::Union{RequestParams, Nothing}: Parameters for the method\nmeta::RequestMeta: Additional metadata for the request\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCResponse","page":"API Reference","title":"ModelContextProtocol.JSONRPCResponse","text":"JSONRPCResponse(; id::RequestId, result::Union{ResponseResult,AbstractDict{String,Any}}) <: Response\n\nJSON-RPC response message returned for successful requests.\n\nFields\n\nid::RequestId: Identifier matching the request this is responding to\nresult::Union{ResponseResult,AbstractDict{String,Any}}: Results of the method execution\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListPromptsParams","page":"API Reference","title":"ModelContextProtocol.ListPromptsParams","text":"ListPromptsParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available prompts from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long prompt lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListPromptsResult","page":"API Reference","title":"ModelContextProtocol.ListPromptsResult","text":"ListPromptsResult(; prompts::Vector{Dict{String,Any}}, \n                nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list prompts request.\n\nFields\n\nprompts::Vector{Dict{String,Any}}: List of available prompts with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more prompts\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListResourcesParams","page":"API Reference","title":"ModelContextProtocol.ListResourcesParams","text":"ListResourcesParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available resources from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long resource lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListResourcesResult","page":"API Reference","title":"ModelContextProtocol.ListResourcesResult","text":"ListResourcesResult(; resources::Vector{Dict{String,Any}}, \n                  nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list resources request.\n\nFields\n\nresources::Vector{Dict{String,Any}}: List of available resources with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more resources\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListToolsParams","page":"API Reference","title":"ModelContextProtocol.ListToolsParams","text":"ListToolsParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available tools from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long tool lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListToolsResult","page":"API Reference","title":"ModelContextProtocol.ListToolsResult","text":"ListToolsResult(; tools::Vector{Dict{String,Any}}, \n              nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list tools request.\n\nFields\n\ntools::Vector{Dict{String,Any}}: List of available tools with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more tools\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ProgressParams","page":"API Reference","title":"ModelContextProtocol.ProgressParams","text":"ProgressParams(; progress_token::ProgressToken, progress::Float64,\n             total::Union{Float64,Nothing}=nothing) <: RequestParams\n\nParameters for progress notifications during long-running operations.\n\nFields\n\nprogress_token::ProgressToken: Token identifying the operation being reported on\nprogress::Float64: Current progress value\ntotal::Union{Float64,Nothing}: Optional total expected value\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ReadResourceParams","page":"API Reference","title":"ModelContextProtocol.ReadResourceParams","text":"ReadResourceParams(; uri::String) <: RequestParams\n\nParameters for requesting the contents of a specific resource.\n\nFields\n\nuri::String: URI identifier of the resource to read\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ReadResourceResult","page":"API Reference","title":"ModelContextProtocol.ReadResourceResult","text":"ReadResourceResult(; contents::Vector{Dict{String,Any}}) <: ResponseResult\n\nResult returned from a read resource request.\n\nFields\n\ncontents::Vector{Dict{String,Any}}: The contents of the requested resource\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestMeta","page":"API Reference","title":"ModelContextProtocol.RequestMeta","text":"RequestMeta(; progress_token::Union{ProgressToken,Nothing}=nothing)\n\nMetadata for MCP protocol requests, including progress tracking information.\n\nFields\n\nprogress_token::Union{ProgressToken,Nothing}: Optional token for tracking request progress\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.get_params_type-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.get_params_type","text":"get_params_type(method::String) -> Union{Type,Nothing}\n\nGet the appropriate parameter type for a given JSON-RPC method name.\n\nArguments\n\nmethod::String: The JSON-RPC method name\n\nReturns\n\nUnion{Type,Nothing}: The Julia type to use for parsing parameters, or nothing if no specific type is defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.get_result_type-Tuple{Union{Int64, String}}","page":"API Reference","title":"ModelContextProtocol.get_result_type","text":"get_result_type(id::RequestId) -> Union{Type{<:ResponseResult},Nothing}\n\nGet the expected result type for a response based on the request ID.\n\nArguments\n\nid::RequestId: The request ID to look up\n\nReturns\n\nUnion{Type{<:ResponseResult},Nothing}: The expected response result type, or nothing if not known\n\nNote: This is a placeholder that needs to be implemented with request tracking.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_error_response-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_error_response","text":"parse_error_response(raw::JSON3.Object) -> Response\n\nParse a JSON-RPC error response object into a typed Response struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing an error response\n\nReturns\n\nResponse: A JSONRPCError with properly typed error information\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_message-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.parse_message","text":"parse_message(json::String) -> MCPMessage\n\nParse a JSON-RPC message string into the appropriate typed message object.\n\nArguments\n\njson::String: The raw JSON-RPC message string\n\nReturns\n\nMCPMessage: A typed MCPMessage subtype (JSONRPCRequest, JSONRPCResponse, JSONRPCNotification, or JSONRPCError)\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_notification-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_notification","text":"parse_notification(raw::JSON3.Object) -> Notification\n\nParse a JSON-RPC notification object into a typed Notification struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a notification\n\nReturns\n\nNotification: A JSONRPCNotification with properly typed parameters if possible\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_request-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_request","text":"parse_request(raw::JSON3.Object) -> Request\n\nParse a JSON-RPC request object into a typed Request struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a request\n\nReturns\n\nRequest: A JSONRPCRequest with properly typed parameters based on the method\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_success_response-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_success_response","text":"parse_success_response(raw::JSON3.Object) -> Response\n\nParse a successful JSON-RPC response object into a typed Response struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a successful response\n\nReturns\n\nResponse: A JSONRPCResponse with properly typed result if possible, or JSONRPCError if parsing fails\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.serialize_message-Tuple{ModelContextProtocol.MCPMessage}","page":"API Reference","title":"ModelContextProtocol.serialize_message","text":"serialize_message(msg::MCPMessage) -> String\n\nSerialize an MCP message object into a JSON-RPC compliant string.\n\nArguments\n\nmsg::MCPMessage: The message object to serialize (Request, Response, Notification, or Error)\n\nReturns\n\nString: A JSON string representation of the message following the JSON-RPC 2.0 specification\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.process_message-Tuple{Server, ModelContextProtocol.ServerState, String}","page":"API Reference","title":"ModelContextProtocol.process_message","text":"process_message(server::Server, state::ServerState, message::String) -> Union{String,Nothing}\n\nProcess an incoming JSON-RPC message and generate an appropriate response.\n\nArguments\n\nserver::Server: The MCP server instance\nstate::ServerState: Current server state\nmessage::String: Raw JSON-RPC message to process\n\nReturns\n\nUnion{String,Nothing}: A serialized response string or nothing for notifications\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.run_server_loop-Tuple{Server, ModelContextProtocol.ServerState}","page":"API Reference","title":"ModelContextProtocol.run_server_loop","text":"run_server_loop(server::Server, state::ServerState) -> Nothing\n\nExecute the main server loop that reads JSON-RPC messages from the transport and writes responses back. Implements optimized CPU usage by blocking on input rather than active polling.\n\nArguments\n\nserver::Server: The MCP server instance with configured transport\nstate::ServerState: The server state object to track running status\n\nReturns\n\nNothing: The function runs until interrupted or state.running becomes false\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.CapabilityResponse","page":"API Reference","title":"ModelContextProtocol.CapabilityResponse","text":"CapabilityResponse(; \n    listChanged::Bool=false, \n    subscribe::Union{Bool,Nothing}=nothing, \n    tools::Union{Dict{String,Any},Nothing}=nothing, \n    resources::Union{Vector{Dict{String,Any}},Nothing}=nothing)\n\nDefine response structure for capabilities including tool and resource listings.\n\nFields\n\nlistChanged::Bool: Whether listings can change during server lifetime.\nsubscribe::Union{Bool,Nothing}: Whether subscriptions are supported.\ntools::Union{Dict{String,Any},Nothing}: Tool definitions by name.\nresources::Union{Vector{Dict{String,Any}},Nothing}: Available resource listings.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.LoggingCapability","page":"API Reference","title":"ModelContextProtocol.LoggingCapability","text":"LoggingCapability(; levels::Vector{String}=[\"info\", \"warn\", \"error\"])\n\nConfigure logging-related capabilities for an MCP server.\n\nFields\n\nlevels::Vector{String}: Supported logging levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptCapability","page":"API Reference","title":"ModelContextProtocol.PromptCapability","text":"PromptCapability(; list_changed::Bool=false)\n\nConfigure prompt-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when prompt listings change.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceCapability","page":"API Reference","title":"ModelContextProtocol.ResourceCapability","text":"ResourceCapability(; list_changed::Bool=false, subscribe::Bool=false)\n\nConfigure resource-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when resource listings change.\nsubscribe::Bool: Whether server supports subscriptions to resource updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ToolCapability","page":"API Reference","title":"ModelContextProtocol.ToolCapability","text":"ToolCapability(; list_changed::Bool=false)\n\nConfigure tool-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when tool listings change.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.capabilities_to_protocol-Tuple{Vector{ModelContextProtocol.Capability}, Server}","page":"API Reference","title":"ModelContextProtocol.capabilities_to_protocol","text":"capabilities_to_protocol(capabilities::Vector{Capability}, server::Server) -> Dict{String,Any}\n\nConvert server capabilities to the initialization response format required by the MCP protocol.\n\nArguments\n\ncapabilities::Vector{Capability}: List of server capabilities.\nserver::Server: The server containing tools and resources.\n\nReturns\n\nDict{String,Any}: Protocol-formatted capabilities dictionary including available tools and resources.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.create_init_response-Tuple{Server, String}","page":"API Reference","title":"ModelContextProtocol.create_init_response","text":"create_init_response(server::Server, protocol_version::String) -> InitializeResult\n\nCreate the initialization response for an MCP server.\n\nArguments\n\nserver::Server: The server to create the response for.\nprotocol_version::String: MCP protocol version string.\n\nReturns\n\nInitializeResult: Initialization response including server capabilities and info.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.merge_capabilities-Tuple{Vector{ModelContextProtocol.Capability}, Vector{ModelContextProtocol.Capability}}","page":"API Reference","title":"ModelContextProtocol.merge_capabilities","text":"merge_capabilities(base::Vector{Capability}, override::Vector{Capability}) -> Vector{Capability}\n\nMerge two sets of capabilities, with the override set taking precedence.\n\nArguments\n\nbase::Vector{Capability}: Base set of capabilities.\noverride::Vector{Capability}: Override capabilities that take precedence.\n\nReturns\n\nVector{Capability}: Merged set of capabilities.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.to_protocol_format-Tuple{ModelContextProtocol.ResourceCapability}","page":"API Reference","title":"ModelContextProtocol.to_protocol_format","text":"to_protocol_format(cap::Capability) -> Dict{String,Any}\n\nConvert an MCP capability to the JSON format expected by the MCP protocol.\n\nArguments\n\ncap::Capability: The capability to convert.\n\nReturns\n\nDict{String,Any}: Protocol-formatted capability dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.auto_register!-Tuple{Server, AbstractString}","page":"API Reference","title":"ModelContextProtocol.auto_register!","text":"auto_register!(server::Server, dir::AbstractString) -> Server\n\nAutomatically register MCP components found in the specified directory structure.\n\nArguments\n\nserver::Server: The server to register components with\ndir::AbstractString: Root directory containing component subdirectories\n\nDirectory Structure\n\ndir/tools/: Contains tool definition files\ndir/resources/: Contains resource definition files\ndir/prompts/: Contains prompt definition files\n\nEach subdirectory is optional. Files should be .jl files containing component definitions.\n\nComponent File Format\n\nComponent files must have the tool/resource/prompt as the last expression in the file. The return value of include() is used to obtain the component.\n\nExample:\n\n# tools/my_tool.jl\njulia_version_tool = MCPTool(\n    name = \"julia_version\",\n    description = \"Get Julia version\",\n    handler = params -> Dict(\"version\" => string(VERSION))\n)  # ← This must be the last expression\n\nReturns\n\nServer: The updated server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.default_capabilities-Tuple{}","page":"API Reference","title":"ModelContextProtocol.default_capabilities","text":"default_capabilities() -> Vector{Capability}\n\nCreate the default set of server capabilities for an MCP server.\n\nReturns\n\nVector{Capability}: Default capabilities including resources, tools, and prompts\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.normalize_path-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.normalize_path","text":"normalize_path(path::String) -> String\n\nConvert paths to absolute form, resolving relative paths against the project root.\n\nArguments\n\npath::String: The path to normalize\n\nReturns\n\nString: Absolute, normalized path with all symbolic links resolved\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.scan_mcp_components-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.scan_mcp_components","text":"scan_mcp_components(dir::String) -> Dict{Symbol,Vector}\n\nScan a directory recursively for MCP component definitions (tools, resources, prompts).\n\nArguments\n\ndir::String: Directory path to scan for component definitions\n\nReturns\n\nDict{Symbol,Vector}: Dictionary of found components grouped by type\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.TransportError","page":"API Reference","title":"ModelContextProtocol.TransportError","text":"TransportError(message::String) <: Exception\n\nException type for transport-specific errors.\n\nFields\n\nmessage::String: The error message describing what went wrong\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.close","page":"API Reference","title":"ModelContextProtocol.close","text":"close(transport::Transport) -> Nothing\n\nClose the transport connection and clean up resources.\n\nArguments\n\ntransport::Transport: The transport instance to close\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.flush-Tuple{Transport}","page":"API Reference","title":"ModelContextProtocol.flush","text":"flush(transport::Transport) -> Nothing\n\nFlush any buffered data in the transport. Default implementation does nothing.\n\nArguments\n\ntransport::Transport: The transport instance to flush\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.is_connected","page":"API Reference","title":"ModelContextProtocol.is_connected","text":"is_connected(transport::Transport) -> Bool\n\nCheck if the transport is currently connected and operational.\n\nArguments\n\ntransport::Transport: The transport instance to check\n\nReturns\n\nBool: true if connected and ready, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.read_message","page":"API Reference","title":"ModelContextProtocol.read_message","text":"read_message(transport::Transport) -> Union{String,Nothing}\n\nRead a single message from the transport.\n\nArguments\n\ntransport::Transport: The transport instance to read from\n\nReturns\n\nUnion{String,Nothing}: The message string if available, or nothing if no message or connection closed\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.write_message","page":"API Reference","title":"ModelContextProtocol.write_message","text":"write_message(transport::Transport, message::String) -> Nothing\n\nWrite a message to the transport.\n\nArguments\n\ntransport::Transport: The transport instance to write to\nmessage::String: The message to send\n\nReturns\n\nNothing\n\nThrows\n\nTransportError: If the message cannot be sent\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.close-Tuple{StdioTransport}","page":"API Reference","title":"ModelContextProtocol.close","text":"close(transport::StdioTransport) -> Nothing\n\nMark the transport as closed. Does not actually close stdin/stdout.\n\nArguments\n\ntransport::StdioTransport: The stdio transport instance\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.flush-Tuple{StdioTransport}","page":"API Reference","title":"ModelContextProtocol.flush","text":"flush(transport::StdioTransport) -> Nothing\n\nFlush the output stream.\n\nArguments\n\ntransport::StdioTransport: The stdio transport instance\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.is_connected-Tuple{StdioTransport}","page":"API Reference","title":"ModelContextProtocol.is_connected","text":"is_connected(transport::StdioTransport) -> Bool\n\nCheck if the stdio transport is connected.\n\nArguments\n\ntransport::StdioTransport: The stdio transport instance\n\nReturns\n\nBool: Connection status\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.read_message-Tuple{StdioTransport}","page":"API Reference","title":"ModelContextProtocol.read_message","text":"read_message(transport::StdioTransport) -> Union{String,Nothing}\n\nRead a line from the input stream.\n\nArguments\n\ntransport::StdioTransport: The stdio transport instance\n\nReturns\n\nUnion{String,Nothing}: The message string, or nothing if empty or EOF\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.write_message-Tuple{StdioTransport, String}","page":"API Reference","title":"ModelContextProtocol.write_message","text":"write_message(transport::StdioTransport, message::String) -> Nothing\n\nWrite a message to the output stream with a newline.\n\nArguments\n\ntransport::StdioTransport: The stdio transport instance\nmessage::String: The message to write\n\nReturns\n\nNothing\n\nThrows\n\nTransportError: If writing fails\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.broadcast_to_sse-Tuple{HttpTransport, String}","page":"API Reference","title":"ModelContextProtocol.broadcast_to_sse","text":"broadcast_to_sse(transport::HttpTransport, message::String; event::String=\"message\") -> Nothing\n\nBroadcast a message immediately to all SSE streams.\n\nArguments\n\ntransport::HttpTransport: The transport instance\nmessage::String: The message to broadcast\nevent::String: The event type (default: \"message\")\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.close-Tuple{HttpTransport}","page":"API Reference","title":"ModelContextProtocol.close","text":"close(transport::HttpTransport) -> Nothing\n\nStop the HTTP server and close all connections.\n\nArguments\n\ntransport::HttpTransport: The transport instance\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.end_response-Tuple{HttpTransport}","page":"API Reference","title":"ModelContextProtocol.end_response","text":"end_response(transport::HttpTransport) -> Nothing\n\nDeprecated: No longer needed as HTTP transport now sends complete responses. This method exists for backward compatibility but does nothing.\n\nArguments\n\ntransport::HttpTransport: The transport instance\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.format_sse_event-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.format_sse_event","text":"format_sse_event(data::String; event::Union{String,Nothing}=nothing, id::Union{Int64,String,Nothing}=nothing) -> String\n\nFormat a message as a Server-Sent Event.\n\nArguments\n\ndata::String: The data to send\nevent::Union{String,Nothing}: Optional event type\nid::Union{Int64,String,Nothing}: Optional event ID\n\nReturns\n\nString: Formatted SSE event\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.generate_session_id-Tuple{}","page":"API Reference","title":"ModelContextProtocol.generate_session_id","text":"generate_session_id() -> String\n\nGenerate a cryptographically secure session ID that meets MCP requirements. Must contain only visible ASCII characters (0x21 to 0x7E).\n\nReturns\n\nString: A valid session ID\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_request-Tuple{HttpTransport, HTTP.Streams.Stream}","page":"API Reference","title":"ModelContextProtocol.handle_request","text":"handle_request(transport::HttpTransport, stream::HTTP.Stream)\n\nHandle incoming HTTP requests following the Streamable HTTP specification. Returns a single JSON response per request.\n\nArguments\n\ntransport::HttpTransport: The transport instance\nstream::HTTP.Stream: The HTTP stream\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_sse_stream-Tuple{HttpTransport, HTTP.Streams.Stream, String}","page":"API Reference","title":"ModelContextProtocol.handle_sse_stream","text":"handle_sse_stream(transport::HttpTransport, stream::HTTP.Stream, stream_id::String)\n\nHandle a Server-Sent Events connection for notifications and streaming responses.\n\nArguments\n\ntransport::HttpTransport: The transport instance\nstream::HTTP.Stream: The HTTP stream\nstream_id::String: Unique identifier for this SSE stream\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.is_connected-Tuple{HttpTransport}","page":"API Reference","title":"ModelContextProtocol.is_connected","text":"is_connected(transport::HttpTransport) -> Bool\n\nCheck if the HTTP server is running and accepting connections.\n\nArguments\n\ntransport::HttpTransport: The transport instance\n\nReturns\n\nBool: true if connected, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.is_valid_session_id-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.is_valid_session_id","text":"is_valid_session_id(session_id::String) -> Bool\n\nValidate that a session ID contains only visible ASCII characters (0x21 to 0x7E).\n\nArguments\n\nsession_id::String: The session ID to validate\n\nReturns\n\nBool: true if valid, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.read_message-Tuple{HttpTransport}","page":"API Reference","title":"ModelContextProtocol.read_message","text":"read_message(transport::HttpTransport) -> Union{String,Nothing}\n\nRead a message from the request queue. Blocks until a request is available or the transport is disconnected.\n\nArguments\n\ntransport::HttpTransport: The transport instance\n\nReturns\n\nUnion{String,Nothing}: The message string, or nothing if disconnected\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.send_notification-Tuple{HttpTransport, String}","page":"API Reference","title":"ModelContextProtocol.send_notification","text":"send_notification(transport::HttpTransport, notification::String) -> Nothing\n\nSend a notification to all connected SSE streams.\n\nArguments\n\ntransport::HttpTransport: The transport instance\nnotification::String: The notification message to send\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.write_message-Tuple{HttpTransport, String}","page":"API Reference","title":"ModelContextProtocol.write_message","text":"write_message(transport::HttpTransport, message::String) -> Nothing\n\nWrite a message to the current request's response channel. The request handler will send this as the HTTP response.\n\nArguments\n\ntransport::HttpTransport: The transport instance\nmessage::String: The message to send\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.MCPLogger","page":"API Reference","title":"ModelContextProtocol.MCPLogger","text":"MCPLogger(stream::IO=stderr, level::LogLevel=Info) -> MCPLogger\n\nCreate a new MCPLogger instance with specified stream and level.\n\nArguments\n\nstream::IO=stderr: The output stream where log messages will be written\nlevel::LogLevel=Info: The minimum logging level to display\n\nReturns\n\nMCPLogger: A new logger instance\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPLogger-2","page":"API Reference","title":"ModelContextProtocol.MCPLogger","text":"MCPLogger <: AbstractLogger\n\nDefine a custom logger for MCP server that formats messages according to protocol requirements.\n\nFields\n\nstream::IO: The output stream for log messages\nmin_level::LogLevel: Minimum logging level to display\nmessage_limits::Dict{Any,Int}: Message limit settings for rate limiting\n\n\n\n\n\n","category":"type"},{"location":"api/#Logging.handle_message-Tuple{ModelContextProtocol.MCPLogger, Vararg{Any, 7}}","page":"API Reference","title":"Logging.handle_message","text":"Logging.handle_message(logger::MCPLogger, level, message, _module, group, id, filepath, line; kwargs...) -> Nothing\n\nFormat and output log messages according to the MCP protocol format.\n\nArguments\n\nlogger::MCPLogger: The MCP logger instance\nlevel: The log level of the message\nmessage: The log message content\n_module: The module where the log was generated\ngroup: The log group\nid: The log message ID\nfilepath: The source file path\nline: The source line number\nkwargs...: Additional contextual information to include in the log\n\nReturns\n\nNothing: Function writes to the logger stream but doesn't return a value\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.init_logging","page":"API Reference","title":"ModelContextProtocol.init_logging","text":"init_logging(level::LogLevel=Info) -> Nothing\n\nInitialize logging for the MCP server with a custom MCP-formatted logger.\n\nArguments\n\nlevel::LogLevel=Info: The minimum logging level to display\n\nReturns\n\nNothing: Function sets the global logger but doesn't return a value\n\n\n\n\n\n","category":"function"},{"location":"api/#StructTypes.omitempties-Tuple{Type{ModelContextProtocol.ClientCapabilities}}","page":"API Reference","title":"StructTypes.omitempties","text":"StructTypes.omitempties(::Type{ClientCapabilities}) -> Tuple{Symbol,Symbol,Symbol}\n\nSpecify which fields should be omitted from JSON serialization when they are empty or null.\n\nArguments\n\n::Type{ClientCapabilities}: The ClientCapabilities type\n\nReturns\n\nTuple{Symbol,Symbol,Symbol}: Fields to omit when empty\n\n\n\n\n\n","category":"method"},{"location":"api/#StructTypes.omitempties-Tuple{Type{ModelContextProtocol.ListPromptsResult}}","page":"API Reference","title":"StructTypes.omitempties","text":"StructTypes.omitempties(::Type{ListPromptsResult}) -> Tuple{Symbol}\n\nSpecify which fields should be omitted from JSON serialization when they are empty or null.\n\nArguments\n\n::Type{ListPromptsResult}: The ListPromptsResult type\n\nReturns\n\nTuple{Symbol}: Fields to omit when empty\n\n\n\n\n\n","category":"method"},{"location":"claude/#Using-with-Claude-Desktop","page":"Claude Desktop","title":"Using with Claude Desktop","text":"ModelContextProtocol.jl can be integrated with Anthropic's Claude Desktop application to allow Claude to access your custom tools, resources, and prompts.","category":"section"},{"location":"claude/#Setup-Instructions","page":"Claude Desktop","title":"Setup Instructions","text":"Launch Claude Desktop application\nGo to File → Settings → Developer\nClick the Edit Config button\nA configuration file will open in your default editor","category":"section"},{"location":"claude/#Configuration","page":"Claude Desktop","title":"Configuration","text":"To register your MCP servers with Claude, modify the configuration file with entries for each server.","category":"section"},{"location":"claude/#Important:-Full-Paths-Required","page":"Claude Desktop","title":"Important: Full Paths Required","text":"⚠️ You must use the full absolute path to your Julia project and scripts. The path should include:\n\nThe --project flag pointing to your ModelContextProtocol.jl directory\nThe full path to the script file","category":"section"},{"location":"claude/#Example-Configuration","page":"Claude Desktop","title":"Example Configuration","text":"{\n  \"mcpServers\": {\n    \"time\": {\n      \"command\": \"julia\",\n      \"args\": [\n        \"--project=/home/username/ModelContextProtocol\",\n        \"/home/username/ModelContextProtocol/examples/time_server.jl\"\n      ],\n      \"env\": {}\n    },\n    \"mcp_tools_example\": {\n      \"command\": \"julia\",\n      \"args\": [\n        \"--project=/home/username/ModelContextProtocol\",\n        \"/home/username/ModelContextProtocol/examples/reg_dir.jl\"\n      ],\n      \"env\": {}\n    },\n    \"http_server\": {\n      \"command\": \"npx\",\n      \"args\": [\"mcp-remote\", \"http://127.0.0.1:3000\", \"--allow-http\"],\n      \"env\": {}\n    }\n  }\n}","category":"section"},{"location":"claude/#Platform-Specific-Path-Examples","page":"Claude Desktop","title":"Platform-Specific Path Examples","text":"macOS/Linux:\n\n\"args\": [\n  \"--project=/home/username/julia_projects/ModelContextProtocol\",\n  \"/home/username/julia_projects/ModelContextProtocol/examples/time_server.jl\"\n]\n\nWindows:\n\n\"args\": [\n  \"--project=C:\\\\Users\\\\username\\\\Documents\\\\ModelContextProtocol\",\n  \"C:\\\\Users\\\\username\\\\Documents\\\\ModelContextProtocol\\\\examples\\\\time_server.jl\"\n]\n\nNote: Julia packages are typically cloned without the .jl extension. If you cloned via Pkg.dev(\"ModelContextProtocol\"), check your .julia/dev/ directory for the exact path.\n\nNote: On Windows, use double backslashes (\\\\) in JSON strings.\n\nFor each server entry:\n\n\"time\", \"mcp_tools_example\": Unique identifiers for your servers (you choose these names)\n\"command\": The command to run (should be \"julia\" for STDIO servers, \"npx\" for HTTP servers via mcp-remote)\n\"args\": Array of arguments:\nFirst argument: \"--project=/full/path/to/ModelContextProtocol\" (the package directory)\nSecond argument: Full path to your server script\n\"env\": Optional environment variables (can be empty {})","category":"section"},{"location":"claude/#Using-HTTP-Servers","page":"Claude Desktop","title":"Using HTTP Servers","text":"For HTTP-based MCP servers, you need to:\n\nStart your HTTP server separately:\ncd /path/to/ModelContextProtocol\njulia --project=. examples/simple_http_server.jl\nOr with full paths:\njulia --project=/home/username/ModelContextProtocol /home/username/ModelContextProtocol/examples/simple_http_server.jl\nNote: The directory is typically ModelContextProtocol without .jl extension.\nConfigure Claude to connect via mcp-remote:\n\"http_server\": {\n  \"command\": \"npx\",\n  \"args\": [\"mcp-remote\", \"http://127.0.0.1:3000\", \"--allow-http\"]\n}\n\nNote: The --allow-http flag is required since ModelContextProtocol.jl currently supports HTTP only, not HTTPS.","category":"section"},{"location":"claude/#Applying-Changes","page":"Claude Desktop","title":"Applying Changes","text":"For configuration changes to take effect:\n\nSave the configuration file\nClose all running Claude processes:\nOn Windows: Use Task Manager to end all Claude processes\nOn macOS: Quit the application\nRestart the Claude Desktop application","category":"section"},{"location":"claude/#Using-Your-MCP-Server","page":"Claude Desktop","title":"Using Your MCP Server","text":"Once configured, you can tell Claude to use your MCP server:\n\nPlease connect to the MCP server named \"time\" and tell me the current time.\n\nClaude will connect to your server, discover available tools and resources, and use them to fulfill your requests.","category":"section"},{"location":"claude/#Troubleshooting","page":"Claude Desktop","title":"Troubleshooting","text":"If Claude cannot connect to your server:\n\nVerify full paths: Ensure you're using absolute paths for both --project and the script file\nCheck directory name: Julia packages are cloned without .jl extension (e.g., ModelContextProtocol not ModelContextProtocol.jl)\nCheck the server name: Must match exactly what's in your configuration\nVerify the paths:\nTest your command in a terminal first:\njulia --project=/your/full/path/ModelContextProtocol /your/full/path/ModelContextProtocol/examples/time_server.jl\nIf this works in terminal, it should work in Claude\nPrecompile dependencies: Run this first to avoid timeout issues:\ncd /path/to/ModelContextProtocol\njulia --project=. -e \"using Pkg; Pkg.instantiate(); using ModelContextProtocol\"\nCheck Claude's Developer Console:\nOpen Claude Desktop\nPress Cmd+Opt+I (Mac) or Ctrl+Shift+I (Windows/Linux)\nLook for error messages in the Console tab","category":"section"},{"location":"claude/#Common-Issues","page":"Claude Desktop","title":"Common Issues","text":"\"Package ModelContextProtocol not found\": The --project path is incorrect\n\"No such file or directory\": The script path is incorrect (check if directory has .jl extension or not)\nServer timeout: Julia compilation is slow on first run - precompile first\nWindows path issues: Remember to use double backslashes in JSON\nWrong directory name: Package directories typically don't include .jl (use ModelContextProtocol not ModelContextProtocol.jl)","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page provides comprehensive examples of using ModelContextProtocol.jl to create MCP servers with various features and configurations.","category":"section"},{"location":"examples/#Basic-Usage","page":"Examples","title":"Basic Usage","text":"","category":"section"},{"location":"examples/#Simple-Echo-Server","page":"Examples","title":"Simple Echo Server","text":"A minimal MCP server with a single tool:\n\nusing ModelContextProtocol\n\n# Create a simple echo tool\necho_tool = MCPTool(\n    name = \"echo\",\n    description = \"Echo back the provided message\",\n    parameters = [\n        ToolParameter(\n            name = \"message\",\n            type = \"string\",\n            description = \"Message to echo back\",\n            required = true\n        )\n    ],\n    handler = function(params)\n        return TextContent(text = \"Echo: $(params[\"message\"])\")\n    end\n)\n\n# Create and configure server\nserver = mcp_server(\n    name = \"echo-server\",\n    version = \"1.0.0\",\n    tools = [echo_tool]\n)\n\n# Display server configuration\nprintln(\"Server created: $(server.config.name) v$(server.config.version)\")\nprintln(\"Available tools: \", [t.name for t in server.tools])","category":"section"},{"location":"examples/#Calculator-Server","page":"Examples","title":"Calculator Server","text":"A server with multiple arithmetic operations:\n\nusing ModelContextProtocol\n\n# Create calculator tool with multiple operations\ncalc_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Perform arithmetic calculations\",\n    parameters = [\n        ToolParameter(name = \"a\", type = \"number\", description = \"First number\", required = true),\n        ToolParameter(name = \"b\", type = \"number\", description = \"Second number\", required = true),\n        ToolParameter(name = \"operation\", type = \"string\",\n                     description = \"Operation: add, subtract, multiply, divide\", required = true)\n    ],\n    handler = function(params)\n        a = params[\"a\"]\n        b = params[\"b\"]\n        op = params[\"operation\"]\n\n        result = if op == \"add\"\n            a + b\n        elseif op == \"subtract\"\n            a - b\n        elseif op == \"multiply\"\n            a * b\n        elseif op == \"divide\"\n            b != 0 ? a / b : \"Error: Division by zero\"\n        else\n            \"Error: Unknown operation\"\n        end\n\n        return TextContent(text = \"Result: $result\")\n    end\n)\n\nserver = mcp_server(\n    name = \"calculator\",\n    version = \"1.0.0\",\n    tools = [calc_tool]\n)\n\nprintln(\"Calculator server configured with tool: $(server.tools[1].name)\")","category":"section"},{"location":"examples/#Advanced-Examples","page":"Examples","title":"Advanced Examples","text":"","category":"section"},{"location":"examples/#Multi-Content-Tool-Returns","page":"Examples","title":"Multi-Content Tool Returns","text":"Tools can return multiple content items of different types:\n\nusing ModelContextProtocol\nusing Base64\n\n# Tool that returns multiple content types\nanalysis_tool = MCPTool(\n    name = \"analyze_data\",\n    description = \"Analyze data and return multiple results\",\n    parameters = [\n        ToolParameter(name = \"data\", type = \"string\", description = \"Data to analyze\", required = true)\n    ],\n    handler = function(params)\n        data = params[\"data\"]\n\n        # Return multiple content items\n        space_char = ' '\n        return [\n            TextContent(text = \"Analysis Summary: Processed $(length(data)) characters\"),\n            TextContent(text = \"Data contains $(count(==(space_char), data)) spaces\"),\n            # Could also include ImageContent with base64 data\n            # ImageContent(data = base64_encoded_image, mime_type = \"image/png\")\n        ]\n    end,\n    return_type = Vector{Content}  # Explicitly specify multi-content return\n)\n\nserver = mcp_server(\n    name = \"analyzer\",\n    version = \"1.0.0\",\n    tools = [analysis_tool]\n)\n\nprintln(\"Multi-content tool configured: $(server.tools[1].name)\")","category":"section"},{"location":"examples/#Resource-Server-with-Custom-Data","page":"Examples","title":"Resource Server with Custom Data","text":"Implementing resources with custom data providers:\n\nusing ModelContextProtocol\nusing URIs  # For URI construction\n\n# Create a resource with a custom data provider\nconfig_resource = MCPResource(\n    uri = URI(\"config://app/settings\"),\n    name = \"Application Settings\",\n    description = \"Current application configuration\",\n    mime_type = \"application/json\",\n    data_provider = function(uri)\n        # In real implementation, read from actual config\n        config_json = \"\"\"\n        {\n            \"theme\": \"dark\",\n            \"language\": \"en\",\n            \"debug\": false\n        }\n        \"\"\"\n        return TextResourceContents(\n            uri = uri,\n            text = config_json,\n            mime_type = \"application/json\"\n        )\n    end,\n    annotations = Dict{String,Any}()\n)\n\n# Create another resource for file access\nfile_resource = MCPResource(\n    uri = URI(\"file:///readme.txt\"),\n    name = \"README File\",\n    description = \"Project readme file\",\n    mime_type = \"text/plain\",\n    data_provider = function(uri)\n        # In real implementation, read the actual file\n        content = \"# Project README\\n\\nThis is the readme content.\"\n        return TextResourceContents(\n            uri = uri,\n            text = content,\n            mime_type = \"text/plain\"\n        )\n    end\n)\n\nserver = mcp_server(\n    name = \"resource-server\",\n    version = \"1.0.0\",\n    resources = [config_resource, file_resource]\n)\n\nprintln(\"Server configured with $(length(server.resources)) resources\")","category":"section"},{"location":"examples/#Prompt-Templates-Server","page":"Examples","title":"Prompt Templates Server","text":"Creating reusable prompt templates:\n\nusing ModelContextProtocol\n\n# Import Role enum values\nuser_role = ModelContextProtocol.user\nassistant_role = ModelContextProtocol.assistant\n\n# Function to generate messages for code review\nfunction generate_code_review_messages(args)\n    lang = args[\"language\"]\n    focus = get(args, \"focus\", \"general quality\")\n    return [\n        PromptMessage(\n            role = user_role,\n            content = TextContent(\n                text = \"Please review this $lang code focusing on $focus. \" *\n                      \"Look for bugs, performance issues, and adherence to best practices.\"\n            )\n        ),\n        PromptMessage(\n            role = assistant_role,\n            content = TextContent(\n                text = \"I'll review your $lang code with a focus on $focus. \" *\n                      \"Please share the code you'd like me to examine.\"\n            )\n        )\n    ]\nend\n\n# Create a code review prompt template\ncode_review_prompt = MCPPrompt(\n    name = \"code_review\",\n    description = \"Generate a code review request\",\n    arguments = [\n        PromptArgument(name = \"language\", description = \"Programming language\", required = true),\n        PromptArgument(name = \"focus\", description = \"Review focus area\", required = false)\n    ],\n    messages = generate_code_review_messages(Dict(\"language\" => \"Julia\", \"focus\" => \"performance\"))\n)\n\n# Create a data analysis prompt with static messages\nanalysis_prompt = MCPPrompt(\n    name = \"data_analysis\",\n    description = \"Request data analysis\",\n    arguments = [\n        PromptArgument(name = \"dataset\", description = \"Dataset description\", required = true)\n    ],\n    messages = [\n        PromptMessage(\n            role = user_role,\n            content = TextContent(\n                text = \"Analyze the dataset. \" *\n                      \"Provide insights on patterns, anomalies, and recommendations.\"\n            )\n        )\n    ]\n)\n\nserver = mcp_server(\n    name = \"prompt-server\",\n    version = \"1.0.0\",\n    prompts = [code_review_prompt, analysis_prompt]\n)\n\nprintln(\"Server configured with prompts: \", [p.name for p in server.prompts])","category":"section"},{"location":"examples/#Transport-Configuration","page":"Examples","title":"Transport Configuration","text":"","category":"section"},{"location":"examples/#HTTP-Transport-with-Custom-Settings","page":"Examples","title":"HTTP Transport with Custom Settings","text":"using ModelContextProtocol\n\n# Note: HttpTransport is an internal type not exported\n# Use stdio transport (default) or specify transport in mcp_server\n# For HTTP servers, the transport is configured internally\n\n# Example server configuration\nserver = mcp_server(\n    name = \"http-server\",\n    version = \"1.0.0\",\n    tools = [\n        MCPTool(\n            name = \"status\",\n            description = \"Get server status\",\n            parameters = [],\n            handler = () -> TextContent(text = \"Server is running\")\n        )\n    ]\n)\n\nprintln(\"Server configured: $(server.config.name)\")","category":"section"},{"location":"examples/#Common-Patterns","page":"Examples","title":"Common Patterns","text":"","category":"section"},{"location":"examples/#Error-Handling-in-Tools","page":"Examples","title":"Error Handling in Tools","text":"Properly handling errors in tool implementations:\n\nusing ModelContextProtocol\n\nsafe_division_tool = MCPTool(\n    name = \"safe_divide\",\n    description = \"Divide two numbers with error handling\",\n    parameters = [\n        ToolParameter(name = \"dividend\", description = \"Number to be divided\", type = \"number\", required = true),\n        ToolParameter(name = \"divisor\", description = \"Number to divide by\", type = \"number\", required = true)\n    ],\n    handler = function(params)\n        dividend = params[\"dividend\"]\n        divisor = params[\"divisor\"]\n\n        # Return error result for invalid input\n        if divisor == 0\n            return CallToolResult(\n                content = [TextContent(text = \"Error: Division by zero is not allowed\")],\n                is_error = true\n            )\n        end\n\n        result = dividend / divisor\n        return TextContent(text = \"Result: $result\")\n    end\n)\n\nserver = mcp_server(\n    name = \"safe-calc\",\n    version = \"1.0.0\",\n    tools = [safe_division_tool]\n)\n\nprintln(\"Error-handling tool configured: $(server.tools[1].name)\")","category":"section"},{"location":"examples/#Directory-Based-Auto-Registration","page":"Examples","title":"Directory-Based Auto-Registration","text":"Organizing components in a directory structure:\n\nusing ModelContextProtocol\n\n# Example directory structure:\n# my_server/\n# ├── tools/\n# │   ├── file_ops.jl    # File operation tools\n# │   └── data_proc.jl   # Data processing tools\n# ├── resources/\n# │   └── configs.jl     # Configuration resources\n# └── prompts/\n#     └── templates.jl   # Prompt templates\n\n# Each file exports components like:\n# file: tools/file_ops.jl\n# read_file = MCPTool(name = \"read_file\", ...)\n# write_file = MCPTool(name = \"write_file\", ...)\n\n# Auto-register all components from directory\nserver = mcp_server(\n    name = \"auto-server\",\n    version = \"2.0.0\",\n    auto_register_dir = \"my_server\"  # Scans and registers all components\n)\n\n# Alternatively, register individual components\nserver2 = mcp_server(name = \"manual-server\", version = \"1.0.0\")\n# Use register! with specific components:\n# register!(server2, my_tool)  # Register a tool\n# register!(server2, my_resource)  # Register a resource\n# register!(server2, my_prompt)  # Register a prompt\n\nprintln(\"Auto-registration example configured\")","category":"section"},{"location":"examples/#Tool-with-Default-Parameters","page":"Examples","title":"Tool with Default Parameters","text":"Using default values for optional parameters:\n\nusing ModelContextProtocol\nusing Dates\n\nformat_date_tool = MCPTool(\n    name = \"format_date\",\n    description = \"Format the current date/time\",\n    parameters = [\n        ToolParameter(\n            name = \"format\",\n            type = \"string\",\n            description = \"Date format string\",\n            required = false,\n            default = \"yyyy-mm-dd HH:MM:SS\"  # Default format\n        ),\n        ToolParameter(\n            name = \"timezone\",\n            type = \"string\",\n            description = \"Timezone (not implemented in this example)\",\n            required = false,\n            default = \"UTC\"\n        )\n    ],\n    handler = function(params)\n        format_str = params[\"format\"]  # Will use default if not provided\n        current_time = Dates.format(now(), format_str)\n        return TextContent(text = \"Current time: $current_time\")\n    end\n)\n\nserver = mcp_server(\n    name = \"time-server\",\n    version = \"1.0.0\",\n    tools = [format_date_tool]\n)\n\nprintln(\"Tool with defaults configured: $(server.tools[1].name)\")","category":"section"},{"location":"examples/#Testing-Your-Implementation","page":"Examples","title":"Testing Your Implementation","text":"","category":"section"},{"location":"examples/#Unit-Testing-Tools","page":"Examples","title":"Unit Testing Tools","text":"Example of testing tool handlers:\n\nusing ModelContextProtocol\nusing Test\n\n# Create a test tool\ntest_tool = MCPTool(\n    name = \"test_tool\",\n    description = \"Tool for testing\",\n    parameters = [\n        ToolParameter(name = \"input\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        return TextContent(text = \"Processed: $(params[\"input\"])\")\n    end\n)\n\n# Test the handler directly\n@testset \"Tool Handler Tests\" begin\n    # Test normal operation\n    result = test_tool.handler(Dict(\"input\" => \"test\"))\n    @test result isa TextContent\n    @test result.text == \"Processed: test\"\n\n    # Test with different inputs\n    result2 = test_tool.handler(Dict(\"input\" => \"hello\"))\n    @test result2.text == \"Processed: hello\"\nend","category":"section"},{"location":"examples/#Integration-Testing-with-curl","page":"Examples","title":"Integration Testing with curl","text":"Testing HTTP server endpoints:\n\n# Start your HTTP server first\njulia --project server_http.jl &\n\n# Wait for server to start\nsleep 5\n\n# Test initialization\ncurl -X POST http://127.0.0.1:8765/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"1.0\"}},\"id\":1}'\n\n# Save session ID from response, then test tool listing\ncurl -X POST http://127.0.0.1:8765/ \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Mcp-Session-Id: YOUR_SESSION_ID\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"params\":{},\"id\":2}'","category":"section"},{"location":"examples/#Best-Practices","page":"Examples","title":"Best Practices","text":"Always validate input parameters in tool handlers\nUse appropriate content types for different data formats\nProvide clear descriptions for tools, resources, and prompts\nHandle errors gracefully with CallToolResult when needed\nTest with MCP Inspector before deploying to production\nUse 127.0.0.1 instead of localhost on Windows for HTTP transport\nOrganize complex servers using directory-based auto-registration\nDocument parameter schemas thoroughly for better LLM understanding","category":"section"},{"location":"examples/#See-Also","page":"Examples","title":"See Also","text":"Tools Documentation for detailed tool implementation\nResources Documentation for resource management\nPrompts Documentation for prompt templates\nAPI Reference for complete function documentation","category":"section"},{"location":"transports/#Transport-Protocols","page":"Transports","title":"Transport Protocols","text":"ModelContextProtocol.jl supports two transport protocols for communication between MCP servers and clients.","category":"section"},{"location":"transports/#stdio-Transport","page":"Transports","title":"stdio Transport","text":"The stdio transport uses standard input and output streams for communication. This is the simplest transport method and works well for command-line applications and process-to-process communication.","category":"section"},{"location":"transports/#Basic-Usage","page":"Transports","title":"Basic Usage","text":"using ModelContextProtocol\n\n# Create a server with stdio transport (default)\nserver = mcp_server(\n    name = \"my-server\",\n    version = \"1.0.0\",\n    tools = [my_tool]\n)\n\n# Start the server (uses stdio by default)\nstart!(server)\n\nThe server will read JSON-RPC messages from stdin and write responses to stdout.","category":"section"},{"location":"transports/#Streamable-HTTP-Transport","page":"Transports","title":"Streamable HTTP Transport","text":"The Streamable HTTP transport implements the MCP protocol over HTTP with Server-Sent Events (SSE) support. This enables web-based clients and provides real-time streaming capabilities.","category":"section"},{"location":"transports/#Basic-HTTP-Server","page":"Transports","title":"Basic HTTP Server","text":"using ModelContextProtocol\nusing ModelContextProtocol: HttpTransport\n\n# Create HTTP transport\ntransport = HttpTransport(\n    host = \"127.0.0.1\",\n    port = 3000,\n    protocol_version = \"2025-06-18\"\n)\n\n# Create server\nserver = mcp_server(\n    name = \"http-server\",\n    version = \"1.0.0\", \n    tools = [my_tool]\n)\n\n# Set transport and start\nserver.transport = transport\nModelContextProtocol.connect(transport)\nstart!(server)","category":"section"},{"location":"transports/#Configuration-Options","page":"Transports","title":"Configuration Options","text":"The HttpTransport constructor accepts several configuration options:\n\ntransport = HttpTransport(\n    host = \"127.0.0.1\",           # Bind address (localhost by default)\n    port = 3000,                  # Port number\n    endpoint = \"/\",               # Base endpoint path\n    protocol_version = \"2025-06-18\",  # MCP protocol version\n    session_required = true,      # Require session validation\n    allowed_origins = [\"http://localhost:8080\"],  # CORS origins\n    enable_sse = true            # Enable Server-Sent Events\n)","category":"section"},{"location":"transports/#Session-Management","page":"Transports","title":"Session Management","text":"HTTP transport uses session-based communication for security and state tracking:\n\nInitialization: Client sends initialization request\nSession Creation: Server responds with Mcp-Session-Id header  \nSubsequent Requests: Client includes session ID in Mcp-Session-Id header\n\n# Initialize and get session ID\ncurl -X POST http://localhost:3000/ \\\n  -H 'Content-Type: application/json' \\\n  -H 'MCP-Protocol-Version: 2025-06-18' \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"initialize\",\"params\":{},\"id\":1}' \\\n  -i\n\n# Use session ID in subsequent requests  \ncurl -X POST http://localhost:3000/ \\\n  -H 'Content-Type: application/json' \\\n  -H 'MCP-Protocol-Version: 2025-06-18' \\\n  -H 'Mcp-Session-Id: <session-id-from-response>' \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"params\":{},\"id\":2}'","category":"section"},{"location":"transports/#Server-Sent-Events-(SSE)","page":"Transports","title":"Server-Sent Events (SSE)","text":"The HTTP transport supports real-time streaming via Server-Sent Events:\n\n# SSE is enabled by default in HttpTransport\ntransport = HttpTransport(enable_sse = true)\n\nSSE streams provide:\n\nReal-time notifications to clients\nProgress updates for long-running operations  \nEvent-based communication patterns\nAutomatic reconnection support","category":"section"},{"location":"transports/#Security-Features","page":"Transports","title":"Security Features","text":"","category":"section"},{"location":"transports/#Origin-Validation","page":"Transports","title":"Origin Validation","text":"Control which origins can access your server:\n\ntransport = HttpTransport(\n    allowed_origins = [\n        \"http://localhost:3000\",\n        \"https://my-app.com\"\n    ]\n)","category":"section"},{"location":"transports/#Session-Validation","page":"Transports","title":"Session Validation","text":"Sessions provide security and state isolation:\n\n# Require valid sessions for all non-initialization requests\ntransport = HttpTransport(session_required = true)\n\n# Disable session requirement (less secure)\ntransport = HttpTransport(session_required = false)","category":"section"},{"location":"transports/#Error-Handling","page":"Transports","title":"Error Handling","text":"The HTTP transport returns appropriate HTTP status codes:\n\n200 OK - Successful requests with JSON response\n202 Accepted - Notification requests (no response body)\n400 Bad Request - Invalid session or malformed requests\n404 Not Found - Unknown endpoints\n500 Internal Server Error - Server-side errors","category":"section"},{"location":"transports/#Performance-Considerations","page":"Transports","title":"Performance Considerations","text":"For production deployments:\n\nBinding: Use host = \"0.0.0.0\" to accept external connections\nPort Selection: Avoid common ports; use application-specific ports\nSession Management: Monitor session count and implement cleanup\nSSE Connections: Limit concurrent SSE streams per client\nOrigin Validation: Always configure allowed origins in production","category":"section"},{"location":"transports/#Troubleshooting","page":"Transports","title":"Troubleshooting","text":"","category":"section"},{"location":"transports/#Connection-Issues","page":"Transports","title":"Connection Issues","text":"# Check if server is listening\nusing Sockets\n@assert isopen(connect(transport.host, transport.port))","category":"section"},{"location":"transports/#Session-Problems","page":"Transports","title":"Session Problems","text":"Ensure Mcp-Session-Id header is included after initialization\nCheck that session ID contains only visible ASCII characters (0x21-0x7E)\nVerify server hasn't restarted (sessions are lost on restart)","category":"section"},{"location":"transports/#Protocol-Version-Mismatches","page":"Transports","title":"Protocol Version Mismatches","text":"Use MCP-Protocol-Version: 2025-06-18 header in all requests\nCheck server logs for protocol version negotiation messages\nEnsure client and server support the same protocol version","category":"section"},{"location":"transports/#Migration-from-stdio","page":"Transports","title":"Migration from stdio","text":"To migrate from stdio to HTTP transport:\n\n# Before (stdio)\nserver = mcp_server(name = \"my-server\", tools = [my_tool])\nstart!(server)\n\n# After (HTTP)\ntransport = HttpTransport(port = 3000)\nserver = mcp_server(name = \"my-server\", tools = [my_tool])\nserver.transport = transport\nModelContextProtocol.connect(transport)\nstart!(server)\n\nKey changes:\n\nCreate and configure HttpTransport\nSet server.transport before starting\nCall ModelContextProtocol.connect(transport) to start HTTP server\nUpdate client code to use HTTP requests with session management","category":"section"},{"location":"transports/#Examples","page":"Transports","title":"Examples","text":"See the examples/ directory for complete working examples:\n\nexamples/streamable_http_basic.jl - Simple HTTP server setup\nexamples/streamable_http_demo.jl - Full-featured server with SSE\nexamples/streamable_http_advanced.jl - Advanced configuration and usage","category":"section"},{"location":"#ModelContextProtocol.jl","page":"Home","title":"ModelContextProtocol.jl","text":"Julia implementation of the Model Context Protocol (MCP), enabling seamless integration between AI applications and external data sources, tools, and services.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"✅ Core MCP 2025-06-18 Protocol - Server-side implementation with tools, resources, and prompts\n✅ Multiple Transports - stdio (default) and HTTP with Server-Sent Events\n✅ Multi-Content Responses - Tools can return text, images, and embedded resources\n✅ Auto-Registration - Automatic component discovery from directory structure\n✅ Type-Safe - Leverages Julia's type system for robust implementations\n✅ Session Management - Secure session handling for HTTP transport\n\nNote: This is a server-side implementation. Client features (roots, sampling), OAuth, and some optional features (elicitation, audio content) are not yet implemented.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"ModelContextProtocol\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Create a simple MCP server with a tool:\n\nusing ModelContextProtocol\n\n# Create a server with a simple echo tool\nserver = mcp_server(\n    name = \"echo-server\",\n    version = \"1.0.0\",\n    tools = [\n        MCPTool(\n            name = \"echo\",\n            description = \"Echo back the input message\",\n            parameters = [\n                ToolParameter(\n                    name = \"message\",\n                    type = \"string\",\n                    description = \"Message to echo\",\n                    required = true\n                )\n            ],\n            handler = (params) -> TextContent(text = params[\"message\"])\n        )\n    ]\n)\n\n# Start the server (stdio transport by default)\nstart!(server)","category":"section"},{"location":"#Using-HTTP-Transport","page":"Home","title":"Using HTTP Transport","text":"For web-based integrations, use the HTTP transport:\n\n# Create server with HTTP transport\nserver = mcp_server(\n    name = \"http-server\",\n    version = \"1.0.0\",\n    tools = [...],  # Your tools here\n    transport = HttpTransport(host = \"127.0.0.1\", port = 3000)\n)\n\nstart!(server)\n\n# Test with curl\n# curl -X POST http://127.0.0.1:3000/ \\\n#   -H \"Content-Type: application/json\" \\\n#   -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"params\":{},\"id\":1}'","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"Examples - Complete working examples and common patterns\nTools - Creating and using MCP tools\nResources - Managing data sources and subscriptions\nPrompts - Defining prompt templates for LLMs\nTransports - Transport options and configuration\nAuto-Registration - Directory-based component organization\nClaude Desktop Integration - Integration with Claude Desktop\nAPI Reference - Complete API documentation","category":"section"},{"location":"#Protocol-Compliance","page":"Home","title":"Protocol Compliance","text":"ModelContextProtocol.jl implements the MCP specification version 2025-06-18, including:\n\nJSON-RPC 2.0 message protocol\nTool discovery and invocation\nResource management with subscriptions\nPrompt templates with arguments\nSession management for HTTP transport\nContent negotiation and multi-format responses","category":"section"},{"location":"#Basic-Concepts","page":"Home","title":"Basic Concepts","text":"","category":"section"},{"location":"#Tools","page":"Home","title":"Tools","text":"Tools are functions that can be invoked by the LLM:\n\ntool = MCPTool(\n    name = \"calculate\",\n    description = \"Perform basic arithmetic\",\n    parameters = [\n        ToolParameter(name = \"a\", type = \"number\", required = true),\n        ToolParameter(name = \"b\", type = \"number\", required = true),\n        ToolParameter(name = \"op\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        a, b = params[\"a\"], params[\"b\"]\n        result = if params[\"op\"] == \"+\"\n            a + b\n        elseif params[\"op\"] == \"-\"\n            a - b\n        elseif params[\"op\"] == \"*\"\n            a * b\n        elseif params[\"op\"] == \"/\"\n            a / b\n        else\n            error(\"Unknown operation\")\n        end\n        return TextContent(text = string(result))\n    end\n)","category":"section"},{"location":"#Resources","page":"Home","title":"Resources","text":"Resources provide data access to the LLM:\n\nresource = MCPResource(\n    uri = \"file:///data/config.json\",\n    name = \"Application Config\",\n    description = \"Current application configuration\",\n    mime_type = \"application/json\",\n    handler = function(uri)\n        config_data = read(\"config.json\", String)\n        return TextResourceContents(\n            uri = uri,\n            text = config_data,\n            mime_type = \"application/json\"\n        )\n    end\n)","category":"section"},{"location":"#Prompts","page":"Home","title":"Prompts","text":"Prompts are templates for generating conversations:\n\nprompt = MCPPrompt(\n    name = \"code_review\",\n    description = \"Request a code review\",\n    arguments = [\n        PromptArgument(\n            name = \"language\",\n            description = \"Programming language\",\n            required = true\n        )\n    ],\n    handler = function(args)\n        return [\n            PromptMessage(\n                role = user,\n                content = TextContent(\n                    text = \"Please review this $(args[\"language\"]) code for best practices.\"\n                )\n            )\n        ]\n    end\n)","category":"section"},{"location":"#Testing-Your-Server","page":"Home","title":"Testing Your Server","text":"","category":"section"},{"location":"#With-MCP-Inspector","page":"Home","title":"With MCP Inspector","text":"Test your server using the official MCP Inspector:\n\n# For stdio transport\nnpx @modelcontextprotocol/inspector stdio -- julia --project server.jl\n\n# For HTTP transport\nnpx @modelcontextprotocol/inspector http://127.0.0.1:3000/","category":"section"},{"location":"#With-curl-(HTTP-only)","page":"Home","title":"With curl (HTTP only)","text":"# Initialize connection\ncurl -X POST http://127.0.0.1:3000/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2025-06-18\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"1.0\"}},\"id\":1}'\n\n# List available tools\ncurl -X POST http://127.0.0.1:3000/ \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Mcp-Session-Id: <session-id-from-init>\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"params\":{},\"id\":2}'","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"Explore the Examples for complete working implementations\nRead the User Guide to understand each component type\nCheck the API Reference for detailed function documentation\nSet up Claude Desktop Integration for real-world usage","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"ModelContextProtocol.jl is part of the JuliaSMLM organization. Contributions are welcome! Please see our GitHub repository for issues and pull requests.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License.","category":"section"},{"location":"auto-registration/#Auto-Registration-System","page":"Auto-Registration","title":"Auto-Registration System","text":"ModelContextProtocol.jl provides an auto-registration system that automatically loads and registers MCP components (tools, prompts, and resources) from a directory structure. This enables clean organization of large MCP servers with many components.","category":"section"},{"location":"auto-registration/#Overview","page":"Auto-Registration","title":"Overview","text":"Instead of manually registering each component, you can organize them in directories and let the system auto-register them:\n\nserver = mcp_server(\n    name = \"my-large-server\",\n    version = \"1.0.0\",\n    auto_register_dir = \"path/to/components\"\n)\n\nThe system will automatically scan for and register all components found in the directory structure.","category":"section"},{"location":"auto-registration/#Directory-Structure","page":"Auto-Registration","title":"Directory Structure","text":"The auto-registration system expects a specific directory layout:\n\ncomponents/\n├── tools/          # MCPTool definitions\n│   ├── data_tools.jl\n│   ├── file_tools.jl\n│   └── math_tools.jl\n├── prompts/        # MCPPrompt definitions  \n│   ├── analysis.jl\n│   └── code_review.jl\n└── resources/      # MCPResource definitions\n    ├── config.jl\n    └── docs.jl\n\nEach subdirectory is scanned for .jl files containing component definitions.","category":"section"},{"location":"auto-registration/#Component-File-Format","page":"Auto-Registration","title":"Component File Format","text":"","category":"section"},{"location":"auto-registration/#Tool-Files-(tools/)","page":"Auto-Registration","title":"Tool Files (tools/)","text":"Each file should define one or more MCPTool instances:\n\n# tools/math_tools.jl\nusing ModelContextProtocol\n\n# Simple calculator tool\ncalculator_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Perform basic arithmetic calculations\",\n    parameters = [\n        ToolParameter(\n            name = \"expression\",\n            type = \"string\",\n            description = \"Mathematical expression to evaluate\",\n            required = true\n        )\n    ],\n    handler = function(params)\n        expr = params[\"expression\"]\n        try\n            result = eval(Meta.parse(expr))\n            return TextContent(text = \"Result: $result\")\n        catch e\n            return TextContent(text = \"Error: $e\")\n        end\n    end\n)\n\n# Statistics tool\nstats_tool = MCPTool(\n    name = \"statistics\",\n    description = \"Calculate statistics for a dataset\",\n    parameters = [\n        ToolParameter(\n            name = \"data\",\n            type = \"array\",\n            description = \"Array of numbers\",\n            required = true\n        )\n    ],\n    handler = function(params)\n        data = params[\"data\"]\n        mean_val = sum(data) / length(data)\n        return TextContent(text = \"Mean: $mean_val\")\n    end\n)","category":"section"},{"location":"auto-registration/#Prompt-Files-(prompts/)","page":"Auto-Registration","title":"Prompt Files (prompts/)","text":"Define MCPPrompt instances for reusable prompt templates:\n\n# prompts/analysis.jl\nusing ModelContextProtocol\n\ndata_analysis_prompt = MCPPrompt(\n    name = \"analyze_data\",\n    description = \"Analyze a dataset and provide insights\",\n    arguments = [\n        PromptArgument(\n            name = \"dataset\",\n            description = \"Description of the dataset to analyze\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"focus_areas\",\n            description = \"Specific areas to focus analysis on\",\n            required = false\n        )\n    ],\n    messages = [\n        PromptMessage(\n            role = ModelContextProtocol.user,\n            content = TextContent(\n                text = \"\"\"Analyze the following dataset: {dataset}\n                \n{?focus_areas?Focus particularly on: {focus_areas}}\n\nProvide:\n1. Key insights and patterns\n2. Statistical summary  \n3. Recommendations for further analysis\"\"\"\n            )\n        )\n    ]\n)","category":"section"},{"location":"auto-registration/#Resource-Files-(resources/)","page":"Auto-Registration","title":"Resource Files (resources/)","text":"Define MCPResource instances for data access:\n\n# resources/config.jl\nusing ModelContextProtocol\nusing URIs\n\napp_config_resource = MCPResource(\n    uri = URI(\"config://app/settings\"),\n    name = \"Application Configuration\",\n    description = \"Current application settings and configuration\",\n    mime_type = \"application/json\",\n    data_provider = function()\n        return Dict(\n            \"version\" => \"1.0.0\",\n            \"debug_mode\" => false,\n            \"max_connections\" => 100,\n            \"features\" => [\n                \"auto_registration\",\n                \"http_transport\",\n                \"sse_streaming\"\n            ]\n        )\n    end\n)","category":"section"},{"location":"auto-registration/#Usage-Examples","page":"Auto-Registration","title":"Usage Examples","text":"","category":"section"},{"location":"auto-registration/#Basic-Auto-Registration","page":"Auto-Registration","title":"Basic Auto-Registration","text":"using ModelContextProtocol\n\n# Create server with auto-registration\nserver = mcp_server(\n    name = \"my-server\",\n    version = \"1.0.0\",\n    auto_register_dir = joinpath(@__DIR__, \"mcp_components\")\n)\n\n# Start server (all components are automatically registered)\nstart!(server)","category":"section"},{"location":"auto-registration/#With-HTTP-Transport","page":"Auto-Registration","title":"With HTTP Transport","text":"using ModelContextProtocol\nusing ModelContextProtocol: HttpTransport\n\n# Create server with auto-registration\nserver = mcp_server(\n    name = \"http-server\",\n    auto_register_dir = \"components\"\n)\n\n# Add HTTP transport\ntransport = HttpTransport(port = 3000)\nserver.transport = transport\nModelContextProtocol.connect(transport)\n\nstart!(server)","category":"section"},{"location":"auto-registration/#Manual-Registration-Combined","page":"Auto-Registration","title":"Manual Registration Combined","text":"You can combine auto-registration with manual registration:\n\n# Manual tool\nmanual_tool = MCPTool(\n    name = \"special_tool\",\n    description = \"Manually registered tool\",\n    parameters = [],\n    handler = params -> TextContent(text = \"Hello from manual tool!\")\n)\n\n# Server with both auto and manual registration\nserver = mcp_server(\n    name = \"mixed-server\",\n    tools = [manual_tool],  # Manual registration\n    auto_register_dir = \"components\"  # Auto registration\n)","category":"section"},{"location":"auto-registration/#Shared-State","page":"Auto-Registration","title":"Shared State","text":"Components loaded via auto-registration can share state through the global Main.storage dictionary:\n\n# In any tool file\nif !isdefined(Main, :storage)\n    Main.storage = Dict{String, Any}()\nend\n\n# Tool that stores data\nstore_tool = MCPTool(\n    name = \"store_data\",\n    description = \"Store data in shared storage\",\n    parameters = [\n        ToolParameter(name = \"key\", type = \"string\", required = true),\n        ToolParameter(name = \"value\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        Main.storage[params[\"key\"]] = params[\"value\"]\n        return TextContent(text = \"Data stored successfully\")\n    end\n)\n\n# Tool that retrieves data\nget_tool = MCPTool(\n    name = \"get_data\", \n    description = \"Get data from shared storage\",\n    parameters = [\n        ToolParameter(name = \"key\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        value = get(Main.storage, params[\"key\"], \"Not found\")\n        return TextContent(text = \"Value: $value\")\n    end\n)","category":"section"},{"location":"auto-registration/#Best-Practices","page":"Auto-Registration","title":"Best Practices","text":"","category":"section"},{"location":"auto-registration/#Organization-Strategies","page":"Auto-Registration","title":"Organization Strategies","text":"By Domain: Group related functionality\ncomponents/\n├── tools/\n│   ├── database_tools.jl\n│   ├── file_tools.jl\n│   └── api_tools.jl\nBy Complexity: Separate simple and complex tools\ncomponents/\n├── tools/\n│   ├── basic/\n│   │   ├── math.jl\n│   │   └── text.jl\n│   └── advanced/\n│       ├── ml_analysis.jl\n│       └── data_processing.jl\nBy Team: Organize by development team\ncomponents/\n├── tools/\n│   ├── backend_team.jl\n│   ├── frontend_team.jl\n│   └── data_team.jl","category":"section"},{"location":"auto-registration/#Component-Design","page":"Auto-Registration","title":"Component Design","text":"Single Responsibility: Each tool should have a clear, focused purpose\nError Handling: Always handle errors gracefully in tool handlers\nDocumentation: Use clear descriptions and parameter documentation\nReturn Types: Be explicit about return types for better error detection\n\nmy_tool = MCPTool(\n    name = \"well_designed_tool\",\n    description = \"Clear description of what this tool does\",\n    parameters = [\n        ToolParameter(\n            name = \"input\",\n            type = \"string\",\n            description = \"Detailed description of this parameter\",\n            required = true\n        )\n    ],\n    handler = function(params)\n        try\n            # Tool logic here\n            result = process(params[\"input\"])\n            return TextContent(text = result)\n        catch e\n            return TextContent(text = \"Error: $(string(e))\")\n        end\n    end,\n    return_type = TextContent  # Explicit return type\n)","category":"section"},{"location":"auto-registration/#Scaling-Considerations","page":"Auto-Registration","title":"Scaling Considerations","text":"Module Isolation: Each component file runs in its own module to avoid conflicts\nStartup Time: Large numbers of components may increase server startup time\nMemory Usage: Monitor memory usage with many auto-registered components\nError Isolation: One broken component file won't prevent others from loading","category":"section"},{"location":"auto-registration/#Troubleshooting","page":"Auto-Registration","title":"Troubleshooting","text":"","category":"section"},{"location":"auto-registration/#Common-Issues","page":"Auto-Registration","title":"Common Issues","text":"Components Not Loading\nCheck file permissions (files must be readable)\nVerify directory structure matches expected layout\nCheck for syntax errors in component files\nImport Errors\nThe auto-registration system automatically imports ModelContextProtocol\nAvoid conflicting using statements in component files\nUse fully qualified names for other packages\nVariable Name Conflicts\nEach component runs in its own module, so variable names are isolated\nGlobal state should use Main.storage, not module-level variables","category":"section"},{"location":"auto-registration/#Debugging","page":"Auto-Registration","title":"Debugging","text":"Enable verbose logging to see what components are being registered:\n\nusing Logging\nglobal_logger(ConsoleLogger(Logging.Debug))\n\nserver = mcp_server(\n    name = \"debug-server\",\n    auto_register_dir = \"components\"\n)\n\nYou'll see messages like:\n\n[ Info: Auto-registering components from /path/to/components\n[ Info: Registered MCPTool from /path/to/components/tools/math.jl: calculator_tool\n[ Info: Registered MCPPrompt from /path/to/components/prompts/analysis.jl: data_analysis_prompt","category":"section"},{"location":"auto-registration/#Complete-Example","page":"Auto-Registration","title":"Complete Example","text":"See examples/reg_dir.jl and examples/reg_dir_http.jl for complete working examples of auto-registration with both stdio and HTTP transports.","category":"section"},{"location":"tools/#MCP-Tools","page":"Tools","title":"MCP Tools","text":"Tools represent callable functions that language models can invoke. Each tool has a name, description, parameters, and a handler function.","category":"section"},{"location":"tools/#Tool-Structure","page":"Tools","title":"Tool Structure","text":"Every tool in ModelContextProtocol.jl is represented by the MCPTool struct, which contains:\n\nname: Unique identifier for the tool\ndescription: Human-readable explanation of the tool's purpose\nparameters: List of input parameters the tool accepts\nhandler: Function that executes when the tool is called\nreturn_type: The expected return type of the handler (defaults to Vector{Content})","category":"section"},{"location":"tools/#Creating-Tools","page":"Tools","title":"Creating Tools","text":"Here's how to create a basic tool:\n\ncalculator_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Perform basic arithmetic\",\n    parameters = [\n        ToolParameter(\n            name = \"expression\",\n            type = \"string\",\n            description = \"Math expression to evaluate\",\n            required = true\n        )\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\n            \"result\" => eval(Meta.parse(params[\"expression\"]))\n        ))\n    )\n)","category":"section"},{"location":"tools/#Parameters","page":"Tools","title":"Parameters","text":"Tool parameters are defined using the ToolParameter struct:\n\nname: Parameter identifier\ndescription: Explanation of the parameter\ntype: JSON schema type (e.g., \"string\", \"number\", \"boolean\")\nrequired: Whether the parameter must be provided (default: false)\ndefault: Default value for the parameter (default: nothing)","category":"section"},{"location":"tools/#Return-Values","page":"Tools","title":"Return Values","text":"Tool handlers can return various types which are automatically converted:\n\nContent instance: A single TextContent, ImageContent, or EmbeddedResource\nVector{<:Content}: Multiple content items (can mix different content types)\nDict: Automatically converted to JSON and wrapped in TextContent\nString: Automatically wrapped in TextContent\nTuple{Vector{UInt8}, String}: Automatically wrapped in ImageContent (bytes, mime_type)\nCallToolResult: For full control over the response including error handling\n\nWhen return_type is Vector{Content} (default), single items are automatically wrapped in a vector.","category":"section"},{"location":"tools/#Registering-Tools","page":"Tools","title":"Registering Tools","text":"Tools can be registered with a server in two ways:\n\nDuring server creation:\n\nserver = mcp_server(\n    name = \"my-server\",\n    tools = my_tool  # Single tool or vector of tools\n)\n\nAfter server creation:\n\nregister!(server, my_tool)","category":"section"},{"location":"tools/#Directory-Based-Organization","page":"Tools","title":"Directory-Based Organization","text":"Tools can be organized in directory structures and auto-registered:\n\nmy_server/\n└── tools/\n    ├── calculator.jl\n    └── time_tool.jl\n\nEach file should export one or more MCPTool instances:\n\n# calculator.jl\nusing ModelContextProtocol\nusing JSON3\n\ncalculator_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Basic calculator\",\n    parameters = [\n        ToolParameter(name = \"expression\", type = \"string\", required = true)\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\"result\" => eval(Meta.parse(params[\"expression\"]))))\n    )\n)\n\nThen auto-register from the directory:\n\nserver = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"section"},{"location":"tools/#Advanced-Examples","page":"Tools","title":"Advanced Examples","text":"","category":"section"},{"location":"tools/#Tool-with-Multiple-Content-Returns","page":"Tools","title":"Tool with Multiple Content Returns","text":"analyze_tool = MCPTool(\n    name = \"analyze_data\",\n    description = \"Analyze data and return text + image\",\n    parameters = [\n        ToolParameter(name = \"data\", description = \"Data to analyze\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        # Return multiple content items\n        return [\n            TextContent(text = \"Analysis complete\"),\n            ImageContent(\n                data = generate_chart_bytes(),  # Your chart generation\n                mime_type = \"image/png\"\n            ),\n            TextContent(text = \"See chart above for details\")\n        ]\n    end,\n    return_type = Vector{Content}\n)","category":"section"},{"location":"tools/#Tool-with-Error-Handling","page":"Tools","title":"Tool with Error Handling","text":"safe_tool = MCPTool(\n    name = \"safe_operation\",\n    description = \"Tool with explicit error handling\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        if !isfile(params[\"path\"])\n            # Return error result\n            return CallToolResult(\n                content = [Dict(\"type\" => \"text\", \"text\" => \"File not found\")],\n                is_error = true\n            )\n        end\n        \n        content = read(params[\"path\"], String)\n        return TextContent(text = content)\n    end\n)","category":"section"}]
}
