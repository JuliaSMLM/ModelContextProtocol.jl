var documenterSearchIndex = {"docs":
[{"location":"prompts/#MCP-Prompts","page":"Prompts","title":"MCP Prompts","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Prompts are template-based messages that language models can use. Each prompt has a name, description, arguments, and message templates.","category":"page"},{"location":"prompts/#Prompt-Structure","page":"Prompts","title":"Prompt Structure","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Every prompt in ModelContextProtocol.jl is represented by the MCPPrompt struct:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"name: Unique identifier for the prompt\ndescription: Human-readable explanation of the prompt's purpose\narguments: List of parameters the prompt accepts\nmessages: Template messages with placeholders for arguments","category":"page"},{"location":"prompts/#Creating-Prompts","page":"Prompts","title":"Creating Prompts","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Here's how to create a basic prompt:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"greeting_prompt = MCPPrompt(\n    name = \"greeting\",\n    description = \"Personalized greeting message\",\n    arguments = [\n        PromptArgument(\n            name = \"name\",\n            description = \"User's name\",\n            required = true\n        ),\n        PromptArgument(\n            name = \"time_of_day\",\n            description = \"Morning, afternoon, or evening\",\n            required = false\n        )\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(\n                text = \"Hello! {?time_of_day?Good {time_of_day}}! My name is {name}.\"\n            )\n        )\n    ]\n)","category":"page"},{"location":"prompts/#Arguments","page":"Prompts","title":"Arguments","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Prompt arguments are defined using the PromptArgument struct:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"name: Parameter identifier\ndescription: Explanation of the parameter\nrequired: Whether the argument must be provided (default: false)","category":"page"},{"location":"prompts/#Template-Syntax","page":"Prompts","title":"Template Syntax","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Prompt templates support parameter substitution and conditional blocks:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Basic substitution: {parameter_name}\nConditional blocks: {?parameter_name?content if parameter exists}","category":"page"},{"location":"prompts/#Registering-Prompts","page":"Prompts","title":"Registering Prompts","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Prompts can be registered with a server in two ways:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"During server creation:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"server = mcp_server(\n    name = \"my-server\",\n    prompts = my_prompt  # Single prompt or vector of prompts\n)","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"After server creation:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"register!(server, my_prompt)","category":"page"},{"location":"prompts/#Directory-Based-Organization","page":"Prompts","title":"Directory-Based Organization","text":"","category":"section"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Prompts can be organized in directory structures and auto-registered:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"my_server/\n└── prompts/\n    ├── greeting.jl\n    └── faq.jl","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Each file should export one or more MCPPrompt instances:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"# greeting.jl\nusing ModelContextProtocol\n\ngreeting_prompt = MCPPrompt(\n    name = \"greeting\",\n    description = \"Personalized greeting message\",\n    arguments = [\n        PromptArgument(name = \"name\", description = \"User's name\", required = true)\n    ],\n    messages = [\n        PromptMessage(\n            role = user,\n            content = TextContent(text = \"Hello! My name is {name}.\")\n        )\n    ]\n)","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"Then auto-register from the directory:","category":"page"},{"location":"prompts/","page":"Prompts","title":"Prompts","text":"server = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"page"},{"location":"resources/#MCP-Resources","page":"Resources","title":"MCP Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Resources provide data that language models can access. Each resource has a URI, name, MIME type, and a data provider function.","category":"page"},{"location":"resources/#Resource-Structure","page":"Resources","title":"Resource Structure","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Every resource in ModelContextProtocol.jl is represented by the MCPResource struct:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"uri: Unique URI identifier for the resource\nname: Human-readable resource name\ndescription: Explanation of the resource's purpose\nmime_type: Content type (e.g., \"application/json\", \"text/plain\")\ndata_provider: Function that returns the resource's data\nannotations: Optional metadata about the resource","category":"page"},{"location":"resources/#Creating-Resources","page":"Resources","title":"Creating Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Here's how to create a basic resource:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"weather_resource = MCPResource(\n    uri = \"mcp://weather/current\",\n    name = \"Current Weather\",\n    description = \"Current weather conditions\",\n    mime_type = \"application/json\",\n    data_provider = () -> Dict(\n        \"temperature\" => 22.5,\n        \"conditions\" => \"Partly Cloudy\",\n        \"updated\" => Dates.format(now(), \"yyyy-mm-dd HH:MM:SS\")\n    )\n)","category":"page"},{"location":"resources/#Data-Providers","page":"Resources","title":"Data Providers","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"The data_provider function should return data in a format compatible with the specified MIME type:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"For JSON resources, return Julia objects that can be JSON-serialized\nFor text resources, return strings\nFor binary resources, return byte arrays","category":"page"},{"location":"resources/#Registering-Resources","page":"Resources","title":"Registering Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Resources can be registered with a server in two ways:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"During server creation:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"server = mcp_server(\n    name = \"my-server\",\n    resources = my_resource  # Single resource or vector of resources\n)","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"After server creation:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"register!(server, my_resource)","category":"page"},{"location":"resources/#Directory-Based-Organization","page":"Resources","title":"Directory-Based Organization","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"Resources can be organized in directory structures and auto-registered:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"my_server/\n└── resources/\n    ├── weather.jl\n    └── stock_data.jl","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"Each file should export one or more MCPResource instances:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"# weather.jl\nusing ModelContextProtocol\nusing Dates\n\nweather_resource = MCPResource(\n    uri = \"mcp://weather/current\",\n    name = \"Current Weather\",\n    description = \"Current weather conditions\",\n    mime_type = \"application/json\",\n    data_provider = () -> Dict(\n        \"temperature\" => 22.5,\n        \"conditions\" => \"Partly Cloudy\",\n        \"updated\" => Dates.format(now(), \"yyyy-mm-dd HH:MM:SS\")\n    )\n)","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"Then auto-register from the directory:","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"server = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page contains the complete API reference for ModelContextProtocol.jl.","category":"page"},{"location":"api/#Base.convert-Tuple{Type{URIs.URI}, String}","page":"API Reference","title":"Base.convert","text":"convert(::Type{URI}, s::String) -> URI\n\nConvert a string to a URI object.\n\nArguments\n\ns::String: The string to convert\n\nReturns\n\nURI: The resulting URI object\n\n\n\n\n\n","category":"method"},{"location":"api/#Logging.handle_message-Tuple{MCPLogger, Vararg{Any, 7}}","page":"API Reference","title":"Logging.handle_message","text":"Logging.handle_message(logger::MCPLogger, level, message, _module, group, id, filepath, line; kwargs...) -> Nothing\n\nFormat and output log messages according to the MCP protocol format.\n\nArguments\n\nlogger::MCPLogger: The MCP logger instance\nlevel: The log level of the message\nmessage: The log message content\n_module: The module where the log was generated\ngroup: The log group\nid: The log message ID\nfilepath: The source file path\nline: The source line number\nkwargs...: Additional contextual information to include in the log\n\nReturns\n\nNothing: Function writes to the logger stream but doesn't return a value\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.api-Tuple{}","page":"API Reference","title":"ModelContextProtocol.api","text":"ModelContextProtocol.jl API Overview\n\nWhat is the Model Context Protocol (MCP)?\n\nThe Model Context Protocol (MCP) is an open standard introduced by Anthropic in 2024 that standardizes how AI applications connect with external tools, data sources, and systems. Think of it as \"USB for AI integrations\" - it provides a universal way for Large Language Models (LLMs) to access and interact with external resources without requiring custom integrations for each combination.\n\nMCP Architecture Overview\n\nMCP follows a client-server architecture built on JSON-RPC 2.0, where:\n\nMCP Hosts: AI applications (Claude Desktop, IDEs, chatbots) that want to access external capabilities\nMCP Clients: Protocol clients embedded within hosts that maintain 1:1 connections with servers  \nMCP Servers: Lightweight programs that expose specific capabilities (tools, resources, prompts) through the standardized protocol\nTransport Layer: Communication mechanism using STDIO (local) or HTTP+SSE (remote)\n\nClient-Server Interaction Flow\n\nWhen an MCP server starts and a client connects, the following happens:\n\nInitialization Handshake: Client and server exchange capabilities and protocol versions\nCapability Discovery: Client requests what features (tools/resources/prompts) the server offers\nRegistration: Server responds with available capabilities, but doesn't send tool details yet\nActive Discovery: Client must explicitly call tools/list, resources/list, or prompts/list to get actual definitions\nInvocation: When the LLM needs to use a tool, the client sends invocation requests to the server\nExecution: Server executes the request and returns structured results\n\nModelContextProtocol.jl's Role\n\nModelContextProtocol.jl is a Julia implementation that makes it extremely easy to create MCP servers. It handles all the protocol complexity, JSON-RPC communication, and provides a developer-friendly API focused on simply defining tools, resources, and prompts.\n\nArchitecture Overview\n\nModelContextProtocol.jl is built around several key architectural principles that make MCP server development intuitive:\n\n1. Auto-Registration System\n\nThe package's flagship feature automatically discovers and registers MCP components without explicit registration code. This leverages Julia's metaprogramming capabilities to scan modules or directories for tool definitions.\n\n2. Content-Centric Design\n\nAll communication revolves around Content objects that provide type safety while allowing flexibility:\n\nabstract type Content end\n\nBase.@kwdef struct TextContent <: Content\n    type::String = \"text\"           # Required by MCP schema\n    text::String                    # The actual text content\n    annotations::AbstractDict{String,Any} = LittleDict{String,Any}()  # Optional metadata\nend\n\nBase.@kwdef struct ImageContent <: Content\n    type::String = \"image\"          # Required by MCP schema\n    data::Vector{UInt8}            # Binary image data (NOT base64 string)\n    mime_type::String              # MIME type of the image\n    annotations::AbstractDict{String,Any} = LittleDict{String,Any}()  # Optional metadata\nend\n\nBase.@kwdef struct EmbeddedResource <: Content\n    type::String = \"resource\"       # Required by MCP schema\n    resource::Union{TextResourceContents, BlobResourceContents}  # The embedded resource\n    annotations::AbstractDict{String,Any} = LittleDict{String,Any}()  # Optional metadata\nend\n\n3. Functional Handler Pattern\n\nTools, prompts, and resources use consistent handler functions:\n\n# Tool handler: Dict -> Content or Vector{Content}\nhandler = (params::Dict) -> TextContent(text = \"Result: $(params[\"input\"])\")\n\n# Resource handler: String -> ResourceContents  \nresource_handler = (uri::String) -> TextResourceContents(uri = uri, text = read(uri, String))\n\n# Prompt handler: Dict -> MCPPromptMessage\nprompt_handler = (args::Dict) -> MCPPromptMessage(role = \"user\", content = TextContent(...))\n\nAuto-Registration System Detailed\n\nThe auto-registration system is the core innovation that eliminates boilerplate. Here's how it works:\n\nDirectory-Based Auto-Registration\n\nThe most powerful approach uses a structured directory layout:\n\nmy_mcp_project/\n├── Project.toml\n├── main.jl                 # Server startup script\n└── mcp_components/         # Auto-registration directory\n    ├── tools/              # Tool definitions\n    │   ├── calculator.jl\n    │   ├── file_reader.jl\n    │   └── web_scraper.jl\n    ├── resources/          # Resource definitions (optional)\n    │   ├── docs.jl\n    │   └── config.jl\n    └── prompts/            # Prompt definitions (optional)\n        └── code_review.jl\n\nHow to Structure Components\n\nEach .jl file in the component directories should define one or more MCP components:\n\ntools/calculator.jl:\n\n# Simple tool definition - no exports or module setup needed\ncalculator = MCPTool(\n    name = \"calculate\",\n    description = \"Perform basic mathematical calculations\",\n    parameters = [\n        ToolParameter(name = \"expression\", description = \"Mathematical expression to evaluate\", type = \"string\", required = true),\n        ToolParameter(name = \"precision\", description = \"Decimal places for rounding\", type = \"number\", default = 2.0)\n    ],\n    handler = function(params)\n        expr = params[\"expression\"]\n        precision = params[\"precision\"]\n        # Note: In production, use a safe expression parser instead of eval\n        result = Base.eval(Main, Meta.parse(expr))\n        return TextContent(text = \"Result: $(round(result, digits=Int(precision)))\")\n    end\n)\n\ntools/file_reader.jl:\n\nusing Base64\n\nfile_tool = MCPTool(\n    name = \"read_file\",\n    description = \"Read and return file contents\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path to read\", type = \"string\", required = true),\n        ToolParameter(name = \"encoding\", description = \"Text encoding\", type = \"string\", default = \"utf-8\")\n    ],\n    handler = function(params)\n        path = params[\"path\"]\n        if !isfile(path)\n            return CallToolResult(\n                content = [TextContent(text = \"File not found: $path\")],\n                is_error = true\n            )\n        end\n        \n        content = read(path, String)\n        return [\n            TextContent(text = \"File: $path\"),\n            TextContent(text = content)\n        ]\n    end,\n    return_type = Vector{Content}\n)\n\nresources/docs.jl:\n\ndocs_resource = MCPResource(\n    uri = \"docs://*\",\n    name = \"Documentation\",\n    description = \"Access to project documentation\",\n    mime_type = \"text/markdown\",\n    data_provider = function(uri::String)\n        # Strip the docs:// prefix and read file\n        file_path = replace(uri, \"docs://\" => \"docs/\")\n        if isfile(file_path)\n            content = read(file_path, String)\n            return TextResourceContents(\n                uri = uri,\n                mime_type = \"text/markdown\",\n                text = content\n            )\n        else\n            error(\"Documentation file not found: $file_path\")\n        end\n    end\n)\n\nServer Startup Script\n\nmain.jl:\n\n#!/usr/bin/env julia\n\nusing Pkg\nPkg.activate(@__DIR__)  # Activate local project environment\n\nusing ModelContextProtocol\n\n# Create server with auto-registration\nserver = mcp_server(\n    name = \"my-awesome-server\",\n    description = \"A comprehensive MCP server with auto-discovered components\",\n    auto_register_dir = \"mcp_components\"  # Scans this directory structure\n)\n\n# Start the server (uses STDIO transport by default)\nprintln(\"Starting MCP Server...\")\nstart!(server)\n\nAdvanced Auto-Registration Features\n\n1. Multiple Variables Per File\n\nFiles can define multiple components:\n\n# tools/math_tools.jl\nadd_tool = MCPTool(\n    name = \"add\",\n    description = \"Add two numbers\", \n    parameters = [\n        ToolParameter(name = \"a\", type = \"number\", required = true),\n        ToolParameter(name = \"b\", type = \"number\", required = true)\n    ],\n    handler = (p) -> TextContent(text = \"$(p[\"a\"] + p[\"b\"])\")\n)\n\nmultiply_tool = MCPTool(\n    name = \"multiply\", \n    description = \"Multiply two numbers\",\n    parameters = [\n        ToolParameter(name = \"a\", type = \"number\", required = true),\n        ToolParameter(name = \"b\", type = \"number\", required = true)\n    ],\n    handler = (p) -> TextContent(text = \"$(p[\"a\"] * p[\"b\"])\")\n)\n\n# Both tools are automatically discovered\n\n2. Auto-Registration Implementation\n\nThe system works by scanning .jl files and looking for variables of the correct types:\n\nfunction auto_register!(server::Server, dir::AbstractString)\n    component_dirs = [\n        (\"tools\", MCPTool),\n        (\"resources\", MCPResource), \n        (\"prompts\", MCPPrompt)\n    ]\n    \n    for (subdir, type) in component_dirs\n        component_dir = joinpath(dir, subdir)\n        if isdir(component_dir)\n            for file in readdir(component_dir, join=true)\n                if endswith(file, \".jl\")\n                    # Create temporary module and include file\n                    mod = Module()\n                    Core.eval(mod, :(using ModelContextProtocol))\n                    Base.include(mod, file)\n                    \n                    # Find all variables matching the target type\n                    for name in names(mod, all=true)\n                        if isdefined(mod, name)\n                            component = getfield(mod, name)\n                            if component isa type\n                                register!(server, component)\n                                @info \"Registered $type from $file: $name\"\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\n\n3. Benefits of Auto-Registration\n\nZero Boilerplate: No manual registration calls needed\nFile-Based Organization: Natural separation of concerns\nDynamic Discovery: Add new tools by creating new files\nError Isolation: Problems in one file don't affect others\nClear Structure: Easy to understand and maintain\n\nModule-Based Registration (Alternative Approach)\n\nFor simpler cases, you can also register from Julia modules:\n\nmodule MyTools\nusing ModelContextProtocol\n\ntime_tool = MCPTool(\n    name = \"current_time\",\n    description = \"Get current time\",\n    parameters = [],\n    handler = (p) -> TextContent(text = string(now()))\n)\n\nweather_tool = MCPTool(\n    name = \"weather\",\n    description = \"Get weather info\",\n    parameters = [ToolParameter(name = \"location\", description = \"Location to get weather for\", type = \"string\", required = true)],\n    handler = (p) -> TextContent(text = \"Weather in $(p[\"location\"]): Sunny\")\n)\nend\n\n# Create server and register tools from module\nserver = mcp_server(name = \"time-weather-server\")\n\n# Manual registration from module\nfor name in names(MyTools, all=true)\n    obj = getfield(MyTools, name)\n    if obj isa MCPTool\n        register!(server, obj)\n    end\nend\n\nstart!(server)\n\nType Hierarchy\n\nContent (abstract)\n├── TextContent            # Has: type=\"text\", text, annotations\n├── ImageContent          # Has: type=\"image\", data::Vector{UInt8}, mime_type, annotations  \n└── EmbeddedResource      # Has: type=\"resource\", resource::Union{TextResourceContents, BlobResourceContents}, annotations\n\nResourceContents (abstract)\n├── TextResourceContents  # Has: uri, text, mime_type::Union{String,Nothing}\n└── BlobResourceContents  # Has: uri, blob::Vector{UInt8}, mime_type::Union{String,Nothing}\n\nTool (abstract)\n└── MCPTool              # Has: name, description, parameters, handler, return_type\n\nResource (abstract)\n└── MCPResource          # Has: uri::URI, name, description, mime_type, data_provider, annotations\n\nMCPPrompt                # Has: name, description, arguments, messages (NO handler - static templates)\nPromptArgument          # Has: name, description, required\nPromptMessage           # Has: content, role\n\nResponseResult (abstract)\n└── CallToolResult       # Has: content::Vector{Dict{String,Any}}, is_error::Bool (NO metadata field)\n\nEssential Types\n\nTool Definition\n\nBase.@kwdef struct MCPTool <: Tool\n    name::String                    # Unique tool identifier\n    description::String             # Human-readable description\n    parameters::Vector{ToolParameter}  # Input parameters schema\n    handler::Function               # Processing function\n    return_type::Type = Vector{Content}  # Expected return type (v0.2+)\nend\n\nBase.@kwdef struct ToolParameter\n    name::String                    # Parameter name\n    description::String             # Parameter description\n    type::String                    # JSON Schema type (\"string\", \"number\", \"boolean\", \"object\", \"array\")\n    required::Bool = false          # Whether parameter is required\n    default::Any = nothing          # Default value if not provided\nend\n\nContent Types\n\n# Text content constructor\nTextContent(text = \"Hello, world!\")\n\n# Image content constructor - note: data is Vector{UInt8}, not base64 string\nImageContent(\n    data = image_bytes,  # Vector{UInt8}\n    mime_type = \"image/png\"\n)\n\n# Embedded resource constructor\nEmbeddedResource(\n    resource = TextResourceContents(\n        uri = \"file:///path/to/file.txt\",\n        text = \"content\"\n    )\n)\n\n# Direct result control (v0.2+) - content is Vector{Dict}, not Vector{Content}\nCallToolResult(\n    content = [Dict(\"type\" => \"text\", \"text\" => \"result\")],  # Pre-serialized\n    is_error = false\n)\n\nResource Definition\n\nBase.@kwdef struct MCPResource <: Resource\n    uri::URI                        # URI pattern (uses URI type, not String)\n    name::String                    # Human-readable name\n    description::String = \"\"        # Resource description\n    mime_type::String = \"application/json\"  # MIME type of resource content\n    data_provider::Function         # Function that provides data (NOT handler)\n    annotations::AbstractDict{String,Any} = LittleDict{String,Any}()  # Optional metadata\nend\n\nBase.@kwdef struct TextResourceContents <: ResourceContents\n    uri::String                     # Actual URI\n    text::String                    # Text content\n    mime_type::Union{String,Nothing} = nothing  # Optional MIME type\nend\n\nBase.@kwdef struct BlobResourceContents <: ResourceContents\n    uri::String                     # Actual URI\n    blob::Vector{UInt8}            # Binary content\n    mime_type::Union{String,Nothing} = nothing  # Optional MIME type\nend\n\nPrompt Definition\n\nBase.@kwdef struct MCPPrompt\n    name::String                           # Prompt identifier\n    description::String = \"\"               # Prompt description\n    arguments::Vector{PromptArgument} = PromptArgument[]  # Input arguments\n    messages::Vector{PromptMessage} = PromptMessage[]     # Static template messages (NO handler)\nend\n\nBase.@kwdef struct PromptArgument\n    name::String                          # Argument name\n    description::String = \"\"              # Argument description\n    required::Bool = false                # Whether required\nend\n\nBase.@kwdef struct PromptMessage\n    content::Union{TextContent, ImageContent, EmbeddedResource}  # Message content\n    role::Role = user                     # Role enum (user or assistant), not String\nend\n\nCore Functions\n\nServer Creation\n\n# Basic server creation\nserver = mcp_server(name = \"my-server\")\n\n# Server with auto-registration \nserver = mcp_server(\n    name = \"auto-server\",\n    description = \"Server with auto-discovered components\",\n    auto_register_dir = \"mcp_components\"\n)\n\n# Server with explicit components\nserver = mcp_server(\n    name = \"explicit-server\", \n    tools = [tool1, tool2],\n    resources = [resource1],\n    prompts = [prompt1]\n)\n\n# Start the server (STDIO transport)\nstart!(server)\n\nComponent Registration\n\n# Manual registration\nregister!(server, my_tool)\nregister!(server, my_resource)\nregister!(server, my_prompt)\n\n# Batch registration\ntools = [tool1, tool2, tool3]\nforeach(t -> register!(server, t), tools)\n\nContent Creation\n\n# Text content\ntext = TextContent(text = \"Hello, world!\")\n\n# Image content (raw bytes - base64 encoding happens automatically during JSON serialization)\nimage = ImageContent(\n    data = image_bytes,  # Vector{UInt8} - raw binary data, NOT base64 string\n    mime_type = \"image/png\"\n)\n\n# Multi-content response\nresults = [\n    TextContent(text = \"Analysis complete\"),\n    ImageContent(data = chart_data, mime_type = \"image/png\"),\n    TextContent(text = \"See chart above for details\")\n]\n\nTool Creation Patterns\n\nSimple Text Tool\n\necho_tool = MCPTool(\n    name = \"echo\",\n    description = \"Echo the input message\",\n    parameters = [\n        ToolParameter(name = \"message\", description = \"Message to echo back\", type = \"string\", required = true)\n    ],\n    handler = (params) -> TextContent(text = params[\"message\"])\n)\n\nTool with Default Parameters\n\nformat_tool = MCPTool(\n    name = \"format_json\",\n    description = \"Format JSON with configurable options\",\n    parameters = [\n        ToolParameter(name = \"json_string\", description = \"JSON string to format\", type = \"string\", required = true),\n        ToolParameter(name = \"indent\", description = \"Number of spaces for indentation\", type = \"number\", default = 2),\n        ToolParameter(name = \"sort_keys\", description = \"Whether to sort object keys\", type = \"boolean\", default = false)\n    ],\n    handler = function(params)\n        data = JSON3.read(params[\"json_string\"])\n        indent = Int(params[\"indent\"])\n        sort_keys = params[\"sort_keys\"]\n        \n        formatted = JSON3.pretty(data, indent = indent, sort_keys = sort_keys)\n        return TextContent(text = formatted)\n    end\n)\n\nMulti-Content Tool\n\nanalyze_tool = MCPTool(\n    name = \"analyze_data\", \n    description = \"Analyze data and return text + visualization\",\n    parameters = [\n        ToolParameter(name = \"data\", description = \"JSON data to analyze\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        # Process data\n        data = JSON3.read(params[\"data\"])\n        \n        # Create summary\n        summary = TextContent(\n            text = \"Data contains $(length(data)) items with keys: $(join(keys(first(data)), \", \"))\"\n        )\n        \n        # Create visualization (mock chart)\n        chart = ImageContent(\n            data = generate_chart_bytes(data),  # Your chart generation function returns Vector{UInt8}\n            mime_type = \"image/png\"\n        )\n        \n        return [summary, chart]  # Return multiple content items\n    end,\n    return_type = Vector{Content}\n)\n\nError-Handling Tool\n\nfile_reader = MCPTool(\n    name = \"read_file\",\n    description = \"Read file with comprehensive error handling\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path to read\", type = \"string\", required = true)\n    ],\n    handler = function(params)\n        path = params[\"path\"]\n        \n        # Validate file exists\n        if !isfile(path)\n            return CallToolResult(\n                content = [TextContent(text = \"Error: File not found at path '$path'\")],\n                is_error = true\n            )\n        end\n        \n        # Check file permissions\n        if !isreadable(path) \n            return CallToolResult(\n                content = [TextContent(text = \"Error: File '$path' is not readable\")],\n                is_error = true\n            )\n        end\n        \n        try\n            content = read(path, String)\n            file_size = filesize(path)\n            \n            return [\n                TextContent(text = \"Successfully read file: $path\"),\n                TextContent(text = \"File size: $file_size bytes\"),\n                TextContent(text = \"Content:\\n$content\")\n            ]\n        catch e\n            return CallToolResult(\n                content = [TextContent(text = \"Error reading file: $(string(e))\")],\n                is_error = true\n            )\n        end\n    end,\n    return_type = Union{Vector{Content}, CallToolResult}\n)\n\nComplete Workflow Examples\n\n1. Creating a File Management Server\n\nProject Structure:\n\nfile_server/\n├── main.jl\n└── mcp_components/\n    ├── tools/\n    │   ├── file_operations.jl\n    │   └── directory_scanner.jl\n    └── resources/\n        └── file_system.jl\n\ntools/file_operations.jl:\n\nusing Base64\n\nread_file = MCPTool(\n    name = \"read_file\",\n    description = \"Read file contents\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path to read\", type = \"string\", required = true),\n        ToolParameter(name = \"max_size\", type = \"number\", default = 1048576)  # 1MB default\n    ],\n    handler = function(params)\n        path = params[\"path\"]\n        max_size = Int(params[\"max_size\"])\n        \n        if !isfile(path)\n            return TextContent(text = \"File not found: $path\")\n        end\n        \n        size = filesize(path)\n        if size > max_size\n            return TextContent(text = \"File too large: $(size) bytes (max: $(max_size))\")\n        end\n        \n        content = read(path, String)\n        return TextContent(text = \"File: $path\\n\\n$content\")\n    end\n)\n\nwrite_file = MCPTool(\n    name = \"write_file\",\n    description = \"Write content to file\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path to read\", type = \"string\", required = true),\n        ToolParameter(name = \"content\", type = \"string\", required = true),\n        ToolParameter(name = \"append\", type = \"boolean\", default = false)\n    ],\n    handler = function(params)\n        path = params[\"path\"]\n        content = params[\"content\"]\n        append_mode = params[\"append\"]\n        \n        try\n            if append_mode\n                open(path, \"a\") do file\n                    write(file, content)\n                end\n            else\n                write(path, content)\n            end\n            \n            return TextContent(text = \"Successfully wrote to $path\")\n        catch e\n            return CallToolResult(\n                content = [TextContent(text = \"Failed to write file: $(string(e))\")],\n                is_error = true\n            )\n        end\n    end\n)\n\ntools/directory_scanner.jl:\n\nlist_directory = MCPTool(\n    name = \"list_directory\",\n    description = \"List directory contents with file information\",\n    parameters = [\n        ToolParameter(name = \"path\", description = \"File path to read\", type = \"string\", required = true),\n        ToolParameter(name = \"recursive\", type = \"boolean\", default = false),\n        ToolParameter(name = \"show_hidden\", type = \"boolean\", default = false)\n    ],\n    handler = function(params)\n        path = params[\"path\"]\n        recursive = params[\"recursive\"]\n        show_hidden = params[\"show_hidden\"]\n        \n        if !isdir(path)\n            return TextContent(text = \"Directory not found: $path\")\n        end\n        \n        files = []\n        if recursive\n            for (root, dirs, filenames) in walkdir(path)\n                for filename in filenames\n                    if show_hidden || !startswith(filename, \".\")\n                        full_path = joinpath(root, filename)\n                        size = filesize(full_path)\n                        modified = Dates.format(Dates.unix2datetime(mtime(full_path)), \"yyyy-mm-dd HH:MM:SS\")\n                        push!(files, \"$full_path ($size bytes, modified: $modified)\")\n                    end\n                end\n            end\n        else\n            for item in readdir(path, join=true)\n                if show_hidden || !startswith(basename(item), \".\")\n                    if isfile(item)\n                        size = filesize(item)\n                        modified = Dates.format(Dates.unix2datetime(mtime(item)), \"yyyy-mm-dd HH:MM:SS\")\n                        push!(files, \"$(basename(item)) ($size bytes, modified: $modified)\")\n                    else\n                        push!(files, \"$(basename(item))/ (directory)\")\n                    end\n                end\n            end\n        end\n        \n        result = \"Directory listing for $path:\\n\" * join(files, \"\\n\")\n        return TextContent(text = result)\n    end\n)\n\nresources/file_system.jl:\n\nfile_system = MCPResource(\n    uri = \"file://*\",\n    name = \"File System Access\",\n    description = \"Direct access to local file system\",\n    mime_type = \"application/octet-stream\",\n    data_provider = function(uri::String)\n        # Remove file:// prefix\n        local_path = replace(uri, \"file://\" => \"\")\n        \n        if isfile(local_path)\n            # Detect MIME type based on extension\n            ext = lowercase(splitext(local_path)[2])\n            mime_type = if ext in [\".txt\", \".md\", \".json\", \".xml\", \".csv\"]\n                \"text/plain\"\n            elseif ext in [\".html\", \".htm\"] \n                \"text/html\"\n            elseif ext in [\".js\"]\n                \"application/javascript\"\n            elseif ext in [\".css\"]\n                \"text/css\"\n            else\n                \"application/octet-stream\"\n            end\n            \n            if startswith(mime_type, \"text/\")\n                content = read(local_path, String)\n                return TextResourceContents(\n                    uri = uri,\n                    mime_type = mime_type,\n                    text = content\n                )\n            else\n                content = read(local_path)\n                return BlobResourceContents(\n                    uri = uri,\n                    mime_type = mime_type,\n                    blob = content\n                )\n            end\n        else\n            error(\"File not found: $local_path\")\n        end\n    end\n)\n\nmain.jl:\n\n#!/usr/bin/env julia\n\nusing Pkg\nPkg.activate(@__DIR__)\n\nusing ModelContextProtocol\n\n# Create server with auto-registration\nserver = mcp_server(\n    name = \"file-management-server\",\n    version = \"2024-11-05\",\n    description = \"Comprehensive file management MCP server\",\n    auto_register_dir = \"mcp_components\"\n)\n\nprintln(\"Starting File Management MCP Server...\")\nprintln(\"Available tools will be auto-discovered from mcp_components/\")\nstart!(server)\n\n2. Creating a Data Analysis Server\n\nProject Structure: \n\ndata_server/\n├── main.jl\n├── data/\n│   ├── sample.csv\n│   └── config.json\n└── mcp_components/\n    ├── tools/\n    │   ├── data_loader.jl\n    │   ├── statistics.jl\n    │   └── visualization.jl\n    └── resources/\n        └── datasets.jl\n\ntools/data_loader.jl:\n\nusing CSV, DataFrames, JSON3\n\nload_csv = MCPTool(\n    name = \"load_csv\",\n    description = \"Load and preview CSV data\",\n    parameters = [\n        ToolParameter(name = \"file_path\", type = \"string\", required = true),\n        ToolParameter(name = \"delimiter\", type = \"string\", default = \",\"),\n        ToolParameter(name = \"preview_rows\", type = \"number\", default = 5)\n    ],\n    handler = function(params)\n        file_path = params[\"file_path\"]\n        delimiter = params[\"delimiter\"][1]  # Convert to char\n        preview_rows = Int(params[\"preview_rows\"])\n        \n        try\n            df = CSV.read(file_path, DataFrame, delim = delimiter)\n            total_rows, total_cols = size(df)\n            \n            # Create summary\n            summary_text = \"\"\"\n            Dataset loaded successfully!\n            - File: $file_path\n            - Dimensions: $total_rows rows × $total_cols columns\n            - Columns: $(join(names(df), \", \"))\n            \"\"\"\n            \n            # Create preview\n            preview_df = first(df, preview_rows)\n            preview_text = sprint(show, preview_df, context = :limit => true)\n            \n            return [\n                TextContent(text = summary_text),\n                TextContent(text = \"Preview (first $preview_rows rows):\\n$preview_text\")\n            ]\n        catch e\n            return CallToolResult(\n                content = [TextContent(text = \"Error loading CSV: $(string(e))\")],\n                is_error = true\n            )\n        end\n    end,\n    return_type = Vector{Content}\n)\n\n3. Running the Servers\n\nTo run any of these servers:\n\n# Navigate to the project directory\ncd file_server/  # or data_server/\n\n# Run the server\njulia main.jl\n\n# The server will start and listen on STDIO\n# Connect from Claude Desktop or other MCP clients\n\nImportant Architecture Patterns\n\n1. Stateless Handlers\n\nHandlers should be pure functions without side effects in server state:\n\n# Good: External state management\nconst cache = Dict{String, Any}()\n\ncached_tool = MCPTool(\n    name = \"cached_compute\",\n    handler = function(params)\n        key = params[\"key\"]\n        if haskey(cache, key)\n            return TextContent(text = \"Cached: $(cache[key])\")\n        end\n        result = expensive_computation(params)\n        cache[key] = result\n        return TextContent(text = \"Computed: $result\")\n    end\n)\n\n2. Content Serialization\n\nThe package automatically serializes content via content2dict (src/utils/serialization.jl):\n\n# Automatic serialization\nTextContent(text = \"Hello\") \n# → {\"type\": \"text\", \"text\": \"Hello\"}\n\nImageContent(data = base64_data, mime_type = \"image/png\")\n# → {\"type\": \"image\", \"data\": \"...\", \"mimeType\": \"image/png\"}\n\n[TextContent(text = \"Part 1\"), TextContent(text = \"Part 2\")]\n# → [{\"type\": \"text\", \"text\": \"Part 1\"}, {\"type\": \"text\", \"text\": \"Part 2\"}]\n\n3. Error Handling Strategies\n\n# Strategy 1: Exception handling (automatic error response)\nerror_tool1 = MCPTool(\n    handler = function(params)\n        if invalid_input(params)\n            error(\"Invalid input provided\")  # Becomes MCP error response\n        end\n        return TextContent(text = \"Success\")\n    end\n)\n\n# Strategy 2: Explicit error control\nerror_tool2 = MCPTool(\n    handler = function(params)\n        if invalid_input(params)\n            return CallToolResult(\n                content = [TextContent(text = \"Validation failed\")],\n                is_error = true\n            )\n        end\n        return TextContent(text = \"Success\")\n    end\n)\n\n4. Performance Considerations\n\nLittleDict Usage: Package uses LittleDict for small dictionaries (< 10 items) for better performance\nLazy Resource Loading: Resources are loaded on-demand via handlers\nContent Chunking: For large content, consider splitting into multiple content items\n\n5. Protocol Compliance\n\nModelContextProtocol.jl ensures MCP compliance automatically:\n\nTools are not included in initialization response (only capability indication)\nClients must call tools/list to discover actual tools\nProper JSON-RPC message formatting\nAutomatic parameter validation and default application\nCorrect error response formatting\n\nThis architecture enables ModelContextProtocol.jl to provide an intuitive, powerful API while maintaining full MCP specification compliance and excellent performance characteristics.\n\n\n\napi() returns this documentation as a plain String.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.auto_register!-Tuple{Server, AbstractString}","page":"API Reference","title":"ModelContextProtocol.auto_register!","text":"auto_register!(server::Server, dir::AbstractString) -> Server\n\nAutomatically register MCP components found in the specified directory structure.\n\nArguments\n\nserver::Server: The server to register components with\ndir::AbstractString: Root directory containing component subdirectories\n\nDirectory Structure\n\ndir/tools/: Contains tool definition files\ndir/resources/: Contains resource definition files\ndir/prompts/: Contains prompt definition files\n\nEach subdirectory is optional. Files should be .jl files containing component definitions.\n\nReturns\n\nServer: The updated server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.capabilities_to_protocol-Tuple{Vector{Capability}, Server}","page":"API Reference","title":"ModelContextProtocol.capabilities_to_protocol","text":"capabilities_to_protocol(capabilities::Vector{Capability}, server::Server) -> Dict{String,Any}\n\nConvert server capabilities to the initialization response format required by the MCP protocol.\n\nArguments\n\ncapabilities::Vector{Capability}: List of server capabilities.\nserver::Server: The server containing tools and resources.\n\nReturns\n\nDict{String,Any}: Protocol-formatted capabilities dictionary including available tools and resources.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.content2dict","page":"API Reference","title":"ModelContextProtocol.content2dict","text":"content2dict(content::Content) -> Dict{String,Any}\n\nConvert a Content object to its dictionary representation for JSON serialization.\n\nArguments\n\ncontent::Content: The content object to convert\n\nReturns\n\nDict{String,Any}: Dictionary representation of the content\n\nExamples\n\ntext_content = TextContent(text=\"Hello\", type=\"text\")\ndict = content2dict(text_content)\n# Returns: Dict(\"type\" => \"text\", \"text\" => \"Hello\", \"annotations\" => Dict())\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.convert_to_content_type-Tuple{Any, Type}","page":"API Reference","title":"ModelContextProtocol.convert_to_content_type","text":"convert_to_content_type(result::Any, return_type::Type) -> Content\n\nConvert various return types to the appropriate MCP Content type.\n\nArguments\n\nresult::Any: The result value to convert\nreturn_type::Type: The target Content type to convert to\n\nReturns\n\nContent: The converted Content object or the original result if no conversion is applicable\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.create_init_response-Tuple{Server, String}","page":"API Reference","title":"ModelContextProtocol.create_init_response","text":"create_init_response(server::Server, protocol_version::String) -> InitializeResult\n\nCreate the initialization response for an MCP server.\n\nArguments\n\nserver::Server: The server to create the response for.\nprotocol_version::String: MCP protocol version string.\n\nReturns\n\nInitializeResult: Initialization response including server capabilities and info.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.default_capabilities-Tuple{}","page":"API Reference","title":"ModelContextProtocol.default_capabilities","text":"default_capabilities() -> Vector{Capability}\n\nCreate the default set of server capabilities for an MCP server.\n\nReturns\n\nVector{Capability}: Default capabilities including resources, tools, and prompts\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.get_params_type-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.get_params_type","text":"get_params_type(method::String) -> Union{Type,Nothing}\n\nGet the appropriate parameter type for a given JSON-RPC method name.\n\nArguments\n\nmethod::String: The JSON-RPC method name\n\nReturns\n\nUnion{Type,Nothing}: The Julia type to use for parsing parameters, or nothing if no specific type is defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.get_result_type-Tuple{Union{Int64, String}}","page":"API Reference","title":"ModelContextProtocol.get_result_type","text":"get_result_type(id::RequestId) -> Union{Type{<:ResponseResult},Nothing}\n\nGet the expected result type for a response based on the request ID.\n\nArguments\n\nid::RequestId: The request ID to look up\n\nReturns\n\nUnion{Type{<:ResponseResult},Nothing}: The expected response result type, or nothing if not known\n\nNote: This is a placeholder that needs to be implemented with request tracking.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_call_tool-Tuple{RequestContext, CallToolParams}","page":"API Reference","title":"ModelContextProtocol.handle_call_tool","text":"handle_call_tool(ctx::RequestContext, params::CallToolParams) -> HandlerResult\n\nHandle requests to call a specific tool with the provided parameters.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::CallToolParams: Parameters containing the tool name and arguments\n\nReturns\n\nHandlerResult: Contains either the tool execution results or an error if the tool is not found or execution fails\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_initialize-Tuple{RequestContext, InitializeParams}","page":"API Reference","title":"ModelContextProtocol.handle_initialize","text":"handle_initialize(ctx::RequestContext, params::InitializeParams) -> HandlerResult\n\nHandle MCP protocol initialization requests by setting up the server and returning capabilities.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::InitializeParams: The initialization parameters from the client\n\nReturns\n\nHandlerResult: Contains the server's capabilities and configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_list_prompts-Tuple{RequestContext, ListPromptsParams}","page":"API Reference","title":"ModelContextProtocol.handle_list_prompts","text":"handle_list_prompts(ctx::RequestContext, params::ListPromptsParams) -> HandlerResult\n\nHandle requests to list available prompts on the MCP server.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::ListPromptsParams: Parameters for the list request (including optional cursor)\n\nReturns\n\nHandlerResult: Contains information about all available prompts\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_list_resources-Tuple{RequestContext, ListResourcesParams}","page":"API Reference","title":"ModelContextProtocol.handle_list_resources","text":"handle_list_resources(ctx::RequestContext, params::ListResourcesParams) -> HandlerResult\n\nHandle requests to list all available resources on the MCP server.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::ListResourcesParams: Parameters for the list request (including optional cursor)\n\nReturns\n\nHandlerResult: Contains information about all registered resources\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_list_tools-Tuple{RequestContext, ListToolsParams}","page":"API Reference","title":"ModelContextProtocol.handle_list_tools","text":"handle_list_tools(ctx::RequestContext, params::ListToolsParams) -> HandlerResult\n\nHandle requests to list all available tools on the MCP server.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::ListToolsParams: Parameters for the list request (including optional cursor)\n\nReturns\n\nHandlerResult: Contains information about all registered tools\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_notification-Tuple{RequestContext, JSONRPCNotification}","page":"API Reference","title":"ModelContextProtocol.handle_notification","text":"handle_notification(ctx::RequestContext, notification::JSONRPCNotification) -> Nothing\n\nProcess notification messages from clients that don't require responses.\n\nArguments\n\nctx::RequestContext: The current request context\nnotification::JSONRPCNotification: The notification to process\n\nReturns\n\nNothing: Notifications don't generate responses\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_ping-Tuple{RequestContext, Nothing}","page":"API Reference","title":"ModelContextProtocol.handle_ping","text":"handle_ping(ctx::RequestContext, params::Nothing) -> HandlerResult\n\nHandle MCP protocol ping requests.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::Nothing: The ping parameters does not contain any data\n\nReturns\n\nHandlerResult: Ping returns an empty response payload\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_read_resource-Tuple{RequestContext, ReadResourceParams}","page":"API Reference","title":"ModelContextProtocol.handle_read_resource","text":"handle_read_resource(ctx::RequestContext, params::ReadResourceParams) -> HandlerResult\n\nHandle requests to read content from a specific resource by URI.\n\nArguments\n\nctx::RequestContext: The current request context\nparams::ReadResourceParams: Parameters containing the URI of the resource to read\n\nReturns\n\nHandlerResult: Contains either the resource contents or an error if the resource  is not found or cannot be read\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.handle_request-Tuple{Server, Request}","page":"API Reference","title":"ModelContextProtocol.handle_request","text":"handle_request(server::Server, request::Request) -> Response\n\nProcess an MCP protocol request and route it to the appropriate handler based on the request method.\n\nArguments\n\nserver::Server: The MCP server instance handling the request\nrequest::Request: The parsed JSON-RPC request to process\n\nBehavior\n\nThis function creates a request context, then dispatches the request to the appropriate handler based on the request method. Supported methods include:\n\ninitialize: Server initialization\nresources/list: List available resources\nresources/read: Read a specific resource\ntools/list: List available tools\ntools/call: Invoke a specific tool\nprompts/list: List available prompts\nprompts/get: Get a specific prompt\n\nIf an unknown method is received, a METHODNOTFOUND error is returned. Any exceptions thrown during processing are caught and converted to INTERNAL_ERROR responses.\n\nReturns\n\nResponse: Either a successful response or an error response depending on the handler result\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.init_logging","page":"API Reference","title":"ModelContextProtocol.init_logging","text":"init_logging(level::LogLevel=Info) -> Nothing\n\nInitialize logging for the MCP server with a custom MCP-formatted logger.\n\nArguments\n\nlevel::LogLevel=Info: The minimum logging level to display\n\nReturns\n\nNothing: Function sets the global logger but doesn't return a value\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.mcp_server-Tuple{}","page":"API Reference","title":"ModelContextProtocol.mcp_server","text":"mcp_server(; name::String, version::String=\"2024-11-05\", \n         tools::Union{Vector{MCPTool},MCPTool,Nothing}=nothing,\n         resources::Union{Vector{MCPResource},MCPResource,Nothing}=nothing, \n         prompts::Union{Vector{MCPPrompt},MCPPrompt,Nothing}=nothing,\n         description::String=\"\", \n         capabilities::Vector{Capability}=default_capabilities(),\n         auto_register_dir::Union{String,Nothing}=nothing) -> Server\n\nPrimary entry point for creating and configuring a Model Context Protocol (MCP) server.\n\nArguments\n\nname::String: Unique identifier for the server instance \nversion::String: Server implementation version\ntools: Tools to expose to the model\nresources: Resources available to the model\nprompts: Predefined prompts for the model\ndescription::String: Optional server description\ncapabilities::Vector{Capability}: Server capability configuration\nauto_register_dir: Directory to auto-register components from\n\nReturns\n\nServer: A configured server instance ready to handle MCP client connections\n\nExample\n\nserver = mcp_server(\n    name = \"my-server\",\n    description = \"Demo server with time tool\",\n    tools = MCPTool(\n        name = \"get_time\",\n        description = \"Get current time\",\n        parameters = [],\n        handler = args -> Dates.format(now(), \"HH:MM:SS\")\n    )\n)\nstart!(server)\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.merge_capabilities-Tuple{Vector{Capability}, Vector{Capability}}","page":"API Reference","title":"ModelContextProtocol.merge_capabilities","text":"merge_capabilities(base::Vector{Capability}, override::Vector{Capability}) -> Vector{Capability}\n\nMerge two sets of capabilities, with the override set taking precedence.\n\nArguments\n\nbase::Vector{Capability}: Base set of capabilities.\noverride::Vector{Capability}: Override capabilities that take precedence.\n\nReturns\n\nVector{Capability}: Merged set of capabilities.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.normalize_path-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.normalize_path","text":"normalize_path(path::String) -> String\n\nConvert paths to absolute form, resolving relative paths against the project root.\n\nArguments\n\npath::String: The path to normalize\n\nReturns\n\nString: Absolute, normalized path with all symbolic links resolved\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_error_response-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_error_response","text":"parse_error_response(raw::JSON3.Object) -> Response\n\nParse a JSON-RPC error response object into a typed Response struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing an error response\n\nReturns\n\nResponse: A JSONRPCError with properly typed error information\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_message-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.parse_message","text":"parse_message(json::String) -> MCPMessage\n\nParse a JSON-RPC message string into the appropriate typed message object.\n\nArguments\n\njson::String: The raw JSON-RPC message string\n\nReturns\n\nMCPMessage: A typed MCPMessage subtype (JSONRPCRequest, JSONRPCResponse, JSONRPCNotification, or JSONRPCError)\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_notification-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_notification","text":"parse_notification(raw::JSON3.Object) -> Notification\n\nParse a JSON-RPC notification object into a typed Notification struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a notification\n\nReturns\n\nNotification: A JSONRPCNotification with properly typed parameters if possible\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_request-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_request","text":"parse_request(raw::JSON3.Object) -> Request\n\nParse a JSON-RPC request object into a typed Request struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a request\n\nReturns\n\nRequest: A JSONRPCRequest with properly typed parameters based on the method\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.parse_success_response-Tuple{JSON3.Object}","page":"API Reference","title":"ModelContextProtocol.parse_success_response","text":"parse_success_response(raw::JSON3.Object) -> Response\n\nParse a successful JSON-RPC response object into a typed Response struct.\n\nArguments\n\nraw::JSON3.Object: The parsed JSON object representing a successful response\n\nReturns\n\nResponse: A JSONRPCResponse with properly typed result if possible, or JSONRPCError if parsing fails\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.process_message-Tuple{Server, ModelContextProtocol.ServerState, String}","page":"API Reference","title":"ModelContextProtocol.process_message","text":"process_message(server::Server, state::ServerState, message::String) -> Union{String,Nothing}\n\nProcess an incoming JSON-RPC message and generate an appropriate response.\n\nArguments\n\nserver::Server: The MCP server instance\nstate::ServerState: Current server state\nmessage::String: Raw JSON-RPC message to process\n\nReturns\n\nUnion{String,Nothing}: A serialized response string or nothing for notifications\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.register!","page":"API Reference","title":"ModelContextProtocol.register!","text":"register!(server::Server, component::Union{Tool,Resource,MCPPrompt}) -> Server\n\nRegister a tool, resource, or prompt with the MCP server.\n\nArguments\n\nserver::Server: The server to register the component with\ncomponent: The component to register (can be a tool, resource, or prompt)\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"function"},{"location":"api/#ModelContextProtocol.run_server_loop-Tuple{Server, ModelContextProtocol.ServerState}","page":"API Reference","title":"ModelContextProtocol.run_server_loop","text":"run_server_loop(server::Server, state::ServerState) -> Nothing\n\nExecute the main server loop that reads JSON-RPC messages from stdin and writes responses to stdout. Implements optimized CPU usage by blocking on input rather than active polling.\n\nArguments\n\nserver::Server: The MCP server instance\nstate::ServerState: The server state object to track running status\n\nReturns\n\nNothing: The function runs until interrupted or state.running becomes false\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.scan_mcp_components-Tuple{String}","page":"API Reference","title":"ModelContextProtocol.scan_mcp_components","text":"scan_mcp_components(dir::String) -> Dict{Symbol,Vector}\n\nScan a directory recursively for MCP component definitions (tools, resources, prompts).\n\nArguments\n\ndir::String: Directory path to scan for component definitions\n\nReturns\n\nDict{Symbol,Vector}: Dictionary of found components grouped by type\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.serialize_message-Tuple{MCPMessage}","page":"API Reference","title":"ModelContextProtocol.serialize_message","text":"serialize_message(msg::MCPMessage) -> String\n\nSerialize an MCP message object into a JSON-RPC compliant string.\n\nArguments\n\nmsg::MCPMessage: The message object to serialize (Request, Response, Notification, or Error)\n\nReturns\n\nString: A JSON string representation of the message following the JSON-RPC 2.0 specification\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.serialize_resource_contents-Tuple{ResourceContents}","page":"API Reference","title":"ModelContextProtocol.serialize_resource_contents","text":"serialize_resource_contents(resource::ResourceContents) -> Dict{String,Any}\n\nSerialize resource contents to protocol format.\n\nArguments\n\nresource::ResourceContents: The resource contents to serialize\n\nReturns\n\nDict{String,Any}: The serialized resource contents\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.start!-Tuple{Server}","page":"API Reference","title":"ModelContextProtocol.start!","text":"start!(server::Server) -> Nothing\n\nStart the MCP server, setting up logging and entering the main server loop.\n\nArguments\n\nserver::Server: The server instance to start\n\nReturns\n\nNothing: The function returns after the server stops\n\nThrows\n\nServerError: If the server is already running\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.stop!-Tuple{Server}","page":"API Reference","title":"ModelContextProtocol.stop!","text":"stop!(server::Server) -> Nothing\n\nStop a running MCP server.\n\nArguments\n\nserver::Server: The server instance to stop\n\nReturns\n\nNothing: The function returns after setting the server to inactive\n\nThrows\n\nServerError: If the server is not currently running\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.subscribe!-Tuple{Server, String, Function}","page":"API Reference","title":"ModelContextProtocol.subscribe!","text":"subscribe!(server::Server, uri::String, callback::Function) -> Server\n\nSubscribe to updates for a specific resource identified by URI.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to subscribe to\ncallback::Function: The function to call when the resource is updated\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.to_protocol_format-Tuple{ResourceCapability}","page":"API Reference","title":"ModelContextProtocol.to_protocol_format","text":"to_protocol_format(cap::Capability) -> Dict{String,Any}\n\nConvert an MCP capability to the JSON format expected by the MCP protocol.\n\nArguments\n\ncap::Capability: The capability to convert.\n\nReturns\n\nDict{String,Any}: Protocol-formatted capability dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.unsubscribe!-Tuple{Server, String, Function}","page":"API Reference","title":"ModelContextProtocol.unsubscribe!","text":"unsubscribe!(server::Server, uri::String, callback::Function) -> Server\n\nRemove a subscription for a specific resource URI and callback function.\n\nArguments\n\nserver::Server: The server instance\nuri::String: The resource URI to unsubscribe from\ncallback::Function: The callback function to remove\n\nReturns\n\nServer: The server instance for method chaining\n\n\n\n\n\n","category":"method"},{"location":"api/#StructTypes.omitempties-Tuple{Type{ClientCapabilities}}","page":"API Reference","title":"StructTypes.omitempties","text":"StructTypes.omitempties(::Type{ClientCapabilities}) -> Tuple{Symbol,Symbol,Symbol}\n\nSpecify which fields should be omitted from JSON serialization when they are empty or null.\n\nArguments\n\n::Type{ClientCapabilities}: The ClientCapabilities type\n\nReturns\n\nTuple{Symbol,Symbol,Symbol}: Fields to omit when empty\n\n\n\n\n\n","category":"method"},{"location":"api/#StructTypes.omitempties-Tuple{Type{ListPromptsResult}}","page":"API Reference","title":"StructTypes.omitempties","text":"StructTypes.omitempties(::Type{ListPromptsResult}) -> Tuple{Symbol}\n\nSpecify which fields should be omitted from JSON serialization when they are empty or null.\n\nArguments\n\n::Type{ListPromptsResult}: The ListPromptsResult type\n\nReturns\n\nTuple{Symbol}: Fields to omit when empty\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.BlobResourceContents","page":"API Reference","title":"ModelContextProtocol.BlobResourceContents","text":"BlobResourceContents(; uri::String, blob::Vector{UInt8}, mime_type::Union{String,Nothing}=nothing) <: ResourceContents\n\nBinary contents for MCP resources.\n\nFields\n\nuri::String: Unique identifier for the resource\nblob::Vector{UInt8}: The binary content of the resource\nmime_type::Union{String,Nothing}: Optional MIME type of the content\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.CallToolParams","page":"API Reference","title":"ModelContextProtocol.CallToolParams","text":"CallToolParams(; name::String, arguments::Union{Dict{String,Any},Nothing}=nothing) <: RequestParams\n\nParameters for invoking a specific tool on an MCP server.\n\nFields\n\nname::String: Name of the tool to call\narguments::Union{Dict{String,Any},Nothing}: Optional arguments to pass to the tool\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.CallToolResult","page":"API Reference","title":"ModelContextProtocol.CallToolResult","text":"CallToolResult(; content::Vector{Dict{String,Any}}, is_error::Bool=false) <: ResponseResult\n\nResult returned from a tool invocation.\n\nFields\n\ncontent::Vector{Dict{String,Any}}: Content produced by the tool\nis_error::Bool: Whether the tool execution resulted in an error\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Capability","page":"API Reference","title":"ModelContextProtocol.Capability","text":"Capability\n\nAbstract base type for all MCP protocol capabilities. Capabilities represent protocol features that servers can support. Concrete implementations define configuration for specific feature sets.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.CapabilityResponse","page":"API Reference","title":"ModelContextProtocol.CapabilityResponse","text":"CapabilityResponse(; \n    listChanged::Bool=false, \n    subscribe::Union{Bool,Nothing}=nothing, \n    tools::Union{Dict{String,Any},Nothing}=nothing, \n    resources::Union{Vector{Dict{String,Any}},Nothing}=nothing)\n\nDefine response structure for capabilities including tool and resource listings.\n\nFields\n\nlistChanged::Bool: Whether listings can change during server lifetime.\nsubscribe::Union{Bool,Nothing}: Whether subscriptions are supported.\ntools::Union{Dict{String,Any},Nothing}: Tool definitions by name.\nresources::Union{Vector{Dict{String,Any}},Nothing}: Available resource listings.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ClientCapabilities","page":"API Reference","title":"ModelContextProtocol.ClientCapabilities","text":"ClientCapabilities(; experimental::Union{Dict{String,Dict{String,Any}},Nothing}=nothing,\n                roots::Union{Dict{String,Bool},Nothing}=nothing,\n                sampling::Union{Dict{String,Any},Nothing}=nothing)\n\nCapabilities reported by an MCP client during initialization.\n\nFields\n\nexperimental::Union{Dict{String,Dict{String,Any}},Nothing}: Experimental features supported\nroots::Union{Dict{String,Bool},Nothing}: Root directories client has access to\nsampling::Union{Dict{String,Any},Nothing}: Sampling capabilities for model generation\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Content","page":"API Reference","title":"ModelContextProtocol.Content","text":"Content\n\nAbstract base type for all content formats in the MCP protocol. Content can be exchanged between clients and servers in various formats.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.EmbeddedResource","page":"API Reference","title":"ModelContextProtocol.EmbeddedResource","text":"EmbeddedResource(; resource::Union{TextResourceContents, BlobResourceContents}, \n                annotations::AbstractDict{String,Any}=LittleDict{String,Any}()) <: Content\n\nEmbedded resource content as defined in MCP schema.\n\nFields\n\ntype::String: Content type identifier (always \"resource\")\nresource::Union{TextResourceContents, BlobResourceContents}: The embedded resource content\nannotations::AbstractDict{String,Any}: Optional metadata about the resource\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ErrorInfo","page":"API Reference","title":"ModelContextProtocol.ErrorInfo","text":"ErrorInfo(; code::Int, message::String, data::Union{Dict{String,Any},Nothing}=nothing)\n\nError information structure for JSON-RPC error responses.\n\nFields\n\ncode::Int: Numeric error code (predefined in ErrorCodes module)\nmessage::String: Human-readable error description\ndata::Union{Dict{String,Any},Nothing}: Optional additional error details\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.GetPromptParams","page":"API Reference","title":"ModelContextProtocol.GetPromptParams","text":"GetPromptParams(; name::String, arguments::Union{Dict{String,String},Nothing}=nothing) <: RequestParams\n\nParameters for requesting a specific prompt from an MCP server.\n\nFields\n\nname::String: Name of the prompt to retrieve\narguments::Union{Dict{String,String},Nothing}: Optional arguments to apply to the prompt template\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.GetPromptResult","page":"API Reference","title":"ModelContextProtocol.GetPromptResult","text":"GetPromptResult(; description::String, messages::Vector{PromptMessage}) <: ResponseResult\n\nResult returned from a get prompt request.\n\nFields\n\ndescription::String: Description of the prompt\nmessages::Vector{PromptMessage}: The prompt messages with template variables replaced\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.HandlerResult","page":"API Reference","title":"ModelContextProtocol.HandlerResult","text":"HandlerResult(; response::Union{Response,Nothing}=nothing, \n            error::Union{ErrorInfo,Nothing}=nothing)\n\nRepresent the result of handling a request.\n\nFields\n\nresponse::Union{Response,Nothing}: The response to send (if successful)\nerror::Union{ErrorInfo,Nothing}: Error information (if request failed)\n\nA HandlerResult must contain either a response or an error, but not both.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ImageContent","page":"API Reference","title":"ModelContextProtocol.ImageContent","text":"ImageContent(; data::Vector{UInt8}, mime_type::String, annotations::AbstractDict{String,Any}=LittleDict{String,Any}()) <: Content\n\nImage-based content for MCP protocol messages.\n\nFields\n\ntype::String: Content type identifier (always \"image\")\ndata::Vector{UInt8}: The binary image data\nmime_type::String: MIME type of the image (e.g., \"image/png\")\nannotations::AbstractDict{String,Any}: Optional metadata about the content\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Implementation","page":"API Reference","title":"ModelContextProtocol.Implementation","text":"Implementation(; name::String=\"default-client\", version::String=\"1.0.0\")\n\nInformation about a client or server implementation of the MCP protocol.\n\nFields\n\nname::String: Name of the implementation\nversion::String: Version string of the implementation\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.InitializeParams","page":"API Reference","title":"ModelContextProtocol.InitializeParams","text":"InitializeParams(; capabilities::ClientCapabilities=ClientCapabilities(),\n               clientInfo::Implementation=Implementation(),\n               protocolVersion::String) <: RequestParams\n\nParameters for MCP protocol initialization requests.\n\nFields\n\ncapabilities::ClientCapabilities: Client capabilities being reported\nclientInfo::Implementation: Information about the client implementation\nprotocolVersion::String: Version of the MCP protocol being used\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.InitializeResult","page":"API Reference","title":"ModelContextProtocol.InitializeResult","text":"InitializeResult(; serverInfo::Dict{String,Any}, capabilities::Dict{String,Any},\n               protocolVersion::String, instructions::String=\"\") <: ResponseResult\n\nResult returned in response to MCP protocol initialization.\n\nFields\n\nserverInfo::Dict{String,Any}: Information about the server implementation\ncapabilities::Dict{String,Any}: Server capabilities being reported\nprotocolVersion::String: Version of the MCP protocol being used\ninstructions::String: Optional usage instructions for clients\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCError","page":"API Reference","title":"ModelContextProtocol.JSONRPCError","text":"JSONRPCError(; id::Union{RequestId,Nothing}, error::ErrorInfo) <: Response\n\nJSON-RPC error response message returned when requests fail.\n\nFields\n\nid::Union{RequestId,Nothing}: Identifier matching the request this is responding to, or null\nerror::ErrorInfo: Information about the error that occurred\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCNotification","page":"API Reference","title":"ModelContextProtocol.JSONRPCNotification","text":"JSONRPCNotification(; method::String, \n                   params::Union{RequestParams,Dict{String,Any}}) <: Notification\n\nJSON-RPC notification message that does not expect a response.\n\nFields\n\nmethod::String: Name of the notification method\nparams::Union{RequestParams,Dict{String,Any}}: Parameters for the notification\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCRequest","page":"API Reference","title":"ModelContextProtocol.JSONRPCRequest","text":"JSONRPCRequest(; id::RequestId, method::String, \n             params::Union{RequestParams, Nothing}, \n             meta::RequestMeta=RequestMeta()) <: Request\n\nJSON-RPC request message used to invoke methods on the server.\n\nFields\n\nid::RequestId: Unique identifier for the request\nmethod::String: Name of the method to invoke\nparams::Union{RequestParams, Nothing}: Parameters for the method\nmeta::RequestMeta: Additional metadata for the request\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.JSONRPCResponse","page":"API Reference","title":"ModelContextProtocol.JSONRPCResponse","text":"JSONRPCResponse(; id::RequestId, result::Union{ResponseResult,AbstractDict{String,Any}}) <: Response\n\nJSON-RPC response message returned for successful requests.\n\nFields\n\nid::RequestId: Identifier matching the request this is responding to\nresult::Union{ResponseResult,AbstractDict{String,Any}}: Results of the method execution\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListPromptsParams","page":"API Reference","title":"ModelContextProtocol.ListPromptsParams","text":"ListPromptsParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available prompts from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long prompt lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListPromptsResult","page":"API Reference","title":"ModelContextProtocol.ListPromptsResult","text":"ListPromptsResult(; prompts::Vector{Dict{String,Any}}, \n                nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list prompts request.\n\nFields\n\nprompts::Vector{Dict{String,Any}}: List of available prompts with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more prompts\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListResourcesParams","page":"API Reference","title":"ModelContextProtocol.ListResourcesParams","text":"ListResourcesParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available resources from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long resource lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListResourcesResult","page":"API Reference","title":"ModelContextProtocol.ListResourcesResult","text":"ListResourcesResult(; resources::Vector{Dict{String,Any}}, \n                  nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list resources request.\n\nFields\n\nresources::Vector{Dict{String,Any}}: List of available resources with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more resources\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListToolsParams","page":"API Reference","title":"ModelContextProtocol.ListToolsParams","text":"ListToolsParams(; cursor::Union{String,Nothing}=nothing) <: RequestParams\n\nParameters for requesting a list of available tools from an MCP server.\n\nFields\n\ncursor::Union{String,Nothing}: Optional pagination cursor for long tool lists\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ListToolsResult","page":"API Reference","title":"ModelContextProtocol.ListToolsResult","text":"ListToolsResult(; tools::Vector{Dict{String,Any}}, \n              nextCursor::Union{String,Nothing}=nothing) <: ResponseResult\n\nResult returned from a list tools request.\n\nFields\n\ntools::Vector{Dict{String,Any}}: List of available tools with their metadata\nnextCursor::Union{String,Nothing}: Optional pagination cursor for fetching more tools\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.LoggingCapability","page":"API Reference","title":"ModelContextProtocol.LoggingCapability","text":"LoggingCapability(; levels::Vector{String}=[\"info\", \"warn\", \"error\"])\n\nConfigure logging-related capabilities for an MCP server.\n\nFields\n\nlevels::Vector{String}: Supported logging levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPLogger","page":"API Reference","title":"ModelContextProtocol.MCPLogger","text":"MCPLogger(stream::IO=stderr, level::LogLevel=Info) -> MCPLogger\n\nCreate a new MCPLogger instance with specified stream and level.\n\nArguments\n\nstream::IO=stderr: The output stream where log messages will be written\nlevel::LogLevel=Info: The minimum logging level to display\n\nReturns\n\nMCPLogger: A new logger instance\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPLogger-2","page":"API Reference","title":"ModelContextProtocol.MCPLogger","text":"MCPLogger <: AbstractLogger\n\nDefine a custom logger for MCP server that formats messages according to protocol requirements.\n\nFields\n\nstream::IO: The output stream for log messages\nmin_level::LogLevel: Minimum logging level to display\nmessage_limits::Dict{Any,Int}: Message limit settings for rate limiting\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPMessage","page":"API Reference","title":"ModelContextProtocol.MCPMessage","text":"MCPMessage\n\nAbstract base type for all message types in the MCP protocol. Serves as the root type for requests, responses, and notifications.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPPrompt","page":"API Reference","title":"ModelContextProtocol.MCPPrompt","text":"MCPPrompt(; name::String, description::String=\"\", \n        arguments::Vector{PromptArgument}=PromptArgument[], \n        messages::Vector{PromptMessage}=PromptMessage[])\n\nImplement a prompt or prompt template as defined in the MCP schema. Prompts can include variables that are replaced with arguments when retrieved.\n\nFields\n\nname::String: Unique identifier for the prompt\ndescription::String: Human-readable description of the prompt's purpose\narguments::Vector{PromptArgument}: Arguments that this prompt accepts\nmessages::Vector{PromptMessage}: The sequence of messages in the prompt\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPPrompt-Tuple{String, String, Vector{PromptArgument}, String}","page":"API Reference","title":"ModelContextProtocol.MCPPrompt","text":"MCPPrompt(name::String, description::String, arguments::Vector{PromptArgument}, text::String) -> MCPPrompt\n\nCreate a prompt with a single text message.\n\nArguments\n\nname::String: Unique identifier for the prompt\ndescription::String: Human-readable description\narguments::Vector{PromptArgument}: Arguments the prompt accepts\ntext::String: Text content for the prompt message\n\nReturns\n\nMCPPrompt: A new prompt with a single user message containing the text\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.MCPResource","page":"API Reference","title":"ModelContextProtocol.MCPResource","text":"MCPResource(; uri, name::String, description::String=\"\",\n          mime_type::String=\"application/json\", data_provider::Function,\n          annotations::Dict{String,Any}=Dict{String,Any}()) <: Resource\n\nImplement a resource that clients can access in the MCP protocol. Resources represent data that can be read by models and tools.\n\nFields\n\nuri::URI: Unique identifier for the resource\nname::String: Human-readable name for the resource\ndescription::String: Detailed description of the resource\nmime_type::String: MIME type of the resource data\ndata_provider::Function: Function that provides the resource data when called\nannotations::AbstractDict{String,Any}: Additional metadata for the resource\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.MCPResource-Tuple{}","page":"API Reference","title":"ModelContextProtocol.MCPResource","text":"MCPResource(; uri, name, description=\"\", mime_type=\"application/json\", \n          data_provider, annotations=LittleDict{String,Any}()) -> MCPResource\n\nCreate a resource with automatic URI conversion from strings.\n\nArguments\n\nuri: String or URI identifier for the resource\nname: Human-readable name for the resource\ndescription: Detailed description\nmime_type: MIME type of the resource\ndata_provider: Function that returns the resource data when called\nannotations: Additional metadata for the resource\n\nReturns\n\nMCPResource: A new resource with the provided configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.MCPTool","page":"API Reference","title":"ModelContextProtocol.MCPTool","text":"MCPTool(; name::String, description::String, parameters::Vector{ToolParameter},\n      handler::Function, return_type::Type=Vector{Content}) <: Tool\n\nImplement a tool that can be invoked by clients in the MCP protocol.\n\nFields\n\nname::String: Unique identifier for the tool\ndescription::String: Human-readable description of the tool's purpose\nparameters::Vector{ToolParameter}: Parameters that the tool accepts\nhandler::Function: Function that implements the tool's functionality\nreturn_type::Type: Expected return type of the handler (defaults to Vector{Content})\n\nHandler Return Types\n\nThe tool handler can return various types which are automatically converted:\n\nAn instance of the specified Content type (TextContent, ImageContent, etc.)\nA Vector{<:Content} for multiple content items (can mix TextContent, ImageContent, etc.)\nA Dict (automatically converted to JSON and wrapped in TextContent)\nA String (automatically wrapped in TextContent)\nA Tuple{Vector{UInt8}, String} (automatically wrapped in ImageContent)\nA CallToolResult object for full control over the response (including error handling)\n\nWhen returntype is Vector{Content} (default), single Content items are automatically wrapped in a vector. Note: When returning CallToolResult directly, the returntype field is ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Notification","page":"API Reference","title":"ModelContextProtocol.Notification","text":"Notification <: MCPMessage\n\nAbstract base type for one-way notifications in the MCP protocol. Notification messages don't expect a corresponding response.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Progress","page":"API Reference","title":"ModelContextProtocol.Progress","text":"Progress(; token::Union{String,Int}, current::Float64, \n        total::Union{Float64,Nothing}=nothing, message::Union{String,Nothing}=nothing)\n\nTracks progress of long-running operations in the MCP protocol.\n\nFields\n\ntoken::Union{String,Int}: Unique identifier for the progress tracker\ncurrent::Float64: Current progress value\ntotal::Union{Float64,Nothing}: Optional total expected value\nmessage::Union{String,Nothing}: Optional status message\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ProgressParams","page":"API Reference","title":"ModelContextProtocol.ProgressParams","text":"ProgressParams(; progress_token::ProgressToken, progress::Float64,\n             total::Union{Float64,Nothing}=nothing) <: RequestParams\n\nParameters for progress notifications during long-running operations.\n\nFields\n\nprogress_token::ProgressToken: Token identifying the operation being reported on\nprogress::Float64: Current progress value\ntotal::Union{Float64,Nothing}: Optional total expected value\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptArgument","page":"API Reference","title":"ModelContextProtocol.PromptArgument","text":"PromptArgument(; name::String, description::String=\"\", required::Bool=false)\n\nDefine an argument that a prompt template can accept.\n\nFields\n\nname::String: The argument name (used in template placeholders)\ndescription::String: Human-readable description of the argument\nrequired::Bool: Whether the argument is required when using the prompt\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptCapability","page":"API Reference","title":"ModelContextProtocol.PromptCapability","text":"PromptCapability(; list_changed::Bool=false)\n\nConfigure prompt-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when prompt listings change.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptMessage","page":"API Reference","title":"ModelContextProtocol.PromptMessage","text":"PromptMessage(; content::Union{TextContent, ImageContent, EmbeddedResource}, role::Role=user)\n\nRepresent a single message in a prompt template.\n\nFields\n\ncontent::Union{TextContent, ImageContent, EmbeddedResource}: The content of the message\nrole::Role: Whether this message is from the user or assistant (defaults to user)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.PromptMessage-Tuple{Union{EmbeddedResource, ImageContent, TextContent}}","page":"API Reference","title":"ModelContextProtocol.PromptMessage","text":"PromptMessage(content::Union{TextContent, ImageContent, EmbeddedResource}) -> PromptMessage\n\nCreate a prompt message with only content (role defaults to user).\n\nArguments\n\ncontent::Union{TextContent, ImageContent, EmbeddedResource}: The message content\n\nReturns\n\nPromptMessage: A new prompt message with the default user role\n\n\n\n\n\n","category":"method"},{"location":"api/#ModelContextProtocol.ReadResourceParams","page":"API Reference","title":"ModelContextProtocol.ReadResourceParams","text":"ReadResourceParams(; uri::String) <: RequestParams\n\nParameters for requesting the contents of a specific resource.\n\nFields\n\nuri::String: URI identifier of the resource to read\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ReadResourceResult","page":"API Reference","title":"ModelContextProtocol.ReadResourceResult","text":"ReadResourceResult(; contents::Vector{Dict{String,Any}}) <: ResponseResult\n\nResult returned from a read resource request.\n\nFields\n\ncontents::Vector{Dict{String,Any}}: The contents of the requested resource\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Request","page":"API Reference","title":"ModelContextProtocol.Request","text":"Request <: MCPMessage\n\nAbstract base type for client-to-server requests in the MCP protocol. Request messages expect a corresponding response from the server.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestContext","page":"API Reference","title":"ModelContextProtocol.RequestContext","text":"RequestContext(; server::Server, request_id::Union{RequestId,Nothing}=nothing, \n             progress_token::Union{ProgressToken,Nothing}=nothing)\n\nStore the current request context for MCP protocol handlers.\n\nFields\n\nserver::Server: The MCP server instance handling the request\nrequest_id::Union{RequestId,Nothing}: The ID of the current request (if any)\nprogress_token::Union{ProgressToken,Nothing}: Optional token for progress reporting\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestHandler","page":"API Reference","title":"ModelContextProtocol.RequestHandler","text":"RequestHandler\n\nDefine base type for all request handlers.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestMeta","page":"API Reference","title":"ModelContextProtocol.RequestMeta","text":"RequestMeta(; progress_token::Union{ProgressToken,Nothing}=nothing)\n\nMetadata for MCP protocol requests, including progress tracking information.\n\nFields\n\nprogress_token::Union{ProgressToken,Nothing}: Optional token for tracking request progress\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestParams","page":"API Reference","title":"ModelContextProtocol.RequestParams","text":"RequestParams\n\nAbstract base type for all parameter structures in MCP protocol requests. Concrete subtypes define parameters for specific request methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Resource","page":"API Reference","title":"ModelContextProtocol.Resource","text":"Resource\n\nAbstract base type for all MCP resources. Resources represent data that can be read and accessed by clients. Concrete implementations define specific resource types and access methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceCapability","page":"API Reference","title":"ModelContextProtocol.ResourceCapability","text":"ResourceCapability(; list_changed::Bool=false, subscribe::Bool=false)\n\nConfigure resource-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when resource listings change.\nsubscribe::Bool: Whether server supports subscriptions to resource updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceContents","page":"API Reference","title":"ModelContextProtocol.ResourceContents","text":"ResourceContents\n\nAbstract base type for contents of MCP resources. ResourceContents represent the actual data stored in resources. Concrete implementations define specific content formats (text, binary, etc.).\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResourceTemplate","page":"API Reference","title":"ModelContextProtocol.ResourceTemplate","text":"ResourceTemplate(; name::String, uri_template::String,\n               mime_type::Union{String,Nothing}=nothing, description::String=\"\")\n\nDefine a template for dynamically generating resources with parameterized URIs.\n\nFields\n\nname::String: Name of the resource template\nuri_template::String: Template string with placeholders for parameters\nmime_type::Union{String,Nothing}: MIME type of the generated resources\ndescription::String: Human-readable description of the template\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Response","page":"API Reference","title":"ModelContextProtocol.Response","text":"Response <: MCPMessage\n\nAbstract base type for server-to-client responses in the MCP protocol. Response messages are sent from the server in reply to client requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ResponseResult","page":"API Reference","title":"ModelContextProtocol.ResponseResult","text":"ResponseResult\n\nAbstract base type for all result structures in MCP protocol responses. Concrete subtypes define result formats for specific response methods.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Role","page":"API Reference","title":"ModelContextProtocol.Role","text":"Role\n\nEnum representing roles in the MCP protocol.\n\nValues\n\nuser: Content or messages from the user\nassistant: Content or messages from the assistant\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Server","page":"API Reference","title":"ModelContextProtocol.Server","text":"Server(config::ServerConfig)\n\nRepresent a running MCP server instance that manages resources, tools, and prompts.\n\nFields\n\nconfig::ServerConfig: Server configuration settings\nresources::Vector{Resource}: Available resources\ntools::Vector{Tool}: Available tools\nprompts::Vector{MCPPrompt}: Available prompts\nresource_templates::Vector{ResourceTemplate}: Available resource templates\nsubscriptions::DefaultDict{String,Vector{Subscription}}: Resource subscription registry\nprogress_trackers::Dict{Union{String,Int},Progress}: Progress tracking for operations\nactive::Bool: Whether the server is currently active\n\nConstructor\n\nServer(config::ServerConfig): Creates a new server with the specified configuration\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ServerConfig","page":"API Reference","title":"ModelContextProtocol.ServerConfig","text":"ServerConfig(; name::String, version::String=\"1.0.0\", \n           description::String=\"\", capabilities::Vector{Capability}=Capability[],\n           instructions::String=\"\")\n\nDefine configuration settings for an MCP server instance.\n\nFields\n\nname::String: The server name shown to clients\nversion::String: Server version string\ndescription::String: Human-readable server description\ncapabilities::Vector{Capability}: Protocol capabilities supported by the server\ninstructions::String: Usage instructions for clients\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ServerError","page":"API Reference","title":"ModelContextProtocol.ServerError","text":"ServerError(message::String) <: Exception\n\nException type for MCP server-specific errors.\n\nFields\n\nmessage::String: The error message describing what went wrong\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ServerState","page":"API Reference","title":"ModelContextProtocol.ServerState","text":"ServerState()\n\nTrack the internal state of an MCP server during operation.\n\nFields\n\ninitialized::Bool: Whether the server has been initialized by a client\nrunning::Bool: Whether the server main loop is active\nlast_request_id::Int: Last used request ID for server-initiated requests\npending_requests::Dict{RequestId,String}: Map of request IDs to method names\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Subscription","page":"API Reference","title":"ModelContextProtocol.Subscription","text":"Subscription(; uri::String, callback::Function, created_at::DateTime=now())\n\nRepresents subscriptions to resource updates in the MCP protocol.\n\nFields\n\nuri::String: The URI of the subscribed resource\ncallback::Function: Function to call when the resource is updated\ncreated_at::DateTime: When the subscription was created\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.TextContent","page":"API Reference","title":"ModelContextProtocol.TextContent","text":"TextContent(; text::String, annotations::AbstractDict{String,Any}=LittleDict{String,Any}()) <: Content\n\nText-based content for MCP protocol messages.\n\nFields\n\ntype::String: Content type identifier (always \"text\")\ntext::String: The actual text content\nannotations::AbstractDict{String,Any}: Optional metadata about the content\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.TextResourceContents","page":"API Reference","title":"ModelContextProtocol.TextResourceContents","text":"TextResourceContents(; uri::String, text::String, mime_type::Union{String,Nothing}=nothing) <: ResourceContents\n\nText-based contents for MCP resources.\n\nFields\n\nuri::String: Unique identifier for the resource\ntext::String: The text content of the resource\nmime_type::Union{String,Nothing}: Optional MIME type of the content\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.Tool","page":"API Reference","title":"ModelContextProtocol.Tool","text":"Tool\n\nAbstract base type for all MCP tools. Tools represent operations that can be invoked by clients. Concrete implementations define specific tool functionality and parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ToolCapability","page":"API Reference","title":"ModelContextProtocol.ToolCapability","text":"ToolCapability(; list_changed::Bool=false)\n\nConfigure tool-related capabilities for an MCP server.\n\nFields\n\nlist_changed::Bool: Whether server supports notifications when tool listings change.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ToolParameter","page":"API Reference","title":"ModelContextProtocol.ToolParameter","text":"ToolParameter(; name::String, description::String, type::String, required::Bool=false, default::Any=nothing)\n\nDefine a parameter for an MCP tool.\n\nFields\n\nname::String: The parameter name (used as the key in the params dictionary)\ndescription::String: Human-readable description of the parameter\ntype::String: Type of the parameter as specified in the MCP schema (e.g., \"string\", \"number\", \"boolean\")\nrequired::Bool: Whether the parameter is required for tool invocation\ndefault::Any: Default value for the parameter if not provided (nothing means no default)\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.ModelContextProtocol","page":"API Reference","title":"ModelContextProtocol.ModelContextProtocol","text":"ModelContextProtocol\n\nJulia implementation of the Model Context Protocol (MCP), enabling standardized communication between AI applications and external tools, resources, and data sources.\n\nQuick Start\n\nCreate and start an MCP server:\n\nusing ModelContextProtocol\n\n# Create a simple server with a tool\nserver = mcp_server(\n    name = \"my-server\",\n    tools = [\n        MCPTool(\n            name = \"hello\",\n            description = \"Say hello\",\n            parameters = [],\n            handler = (p) -> TextContent(text = \"Hello, world!\")\n        )\n    ]\n)\n\nstart!(server)\n\nAPI Overview\n\nFor a comprehensive overview of the API, use the help mode on api:\n\n?ModelContextProtocol.api\n\nOr access the complete API documentation programmatically:\n\ndocs = ModelContextProtocol.api()\n\nSee Also\n\nmcp_server - Create an MCP server instance\nMCPTool - Define tools that can be invoked by clients\nMCPResource - Define resources that can be accessed by clients\nMCPPrompt - Define prompt templates for LLMs\n\n\n\n\n\n","category":"module"},{"location":"api/#ModelContextProtocol.ProgressToken","page":"API Reference","title":"ModelContextProtocol.ProgressToken","text":"ProgressToken\n\nType alias for tokens used to track long-running operations.\n\nType\n\nUnion{String,Int} - Can be either a string or integer identifier\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelContextProtocol.RequestId","page":"API Reference","title":"ModelContextProtocol.RequestId","text":"RequestId\n\nType alias for JSON-RPC request identifiers.\n\nType\n\nUnion{String,Int} - Can be either a string or integer identifier\n\n\n\n\n\n","category":"type"},{"location":"claude/#Using-with-Claude-Desktop","page":"Claude Integration","title":"Using with Claude Desktop","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"ModelContextProtocol.jl can be integrated with Anthropic's Claude Desktop application to allow Claude to access your custom tools, resources, and prompts.","category":"page"},{"location":"claude/#Setup-Instructions","page":"Claude Integration","title":"Setup Instructions","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Launch Claude Desktop application\nGo to File → Settings → Developer\nClick the Edit Config button\nA configuration file will open in your default editor","category":"page"},{"location":"claude/#Configuration","page":"Claude Integration","title":"Configuration","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"To register your MCP servers with Claude, modify the configuration file with entries for each server:","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"{\n  \"mcpServers\": {\n    \"time\": {\n      \"command\": \"julia\",\n      \"args\": [\n        \"/path/to/ModelContextProtocol/examples/time_server.jl\"\n      ],\n      \"env\": {}\n    },\n    \"mcp_tools_example\": {\n      \"command\": \"julia\",\n      \"args\": [\n        \"/path/to/ModelContextProtocol/examples/reg_dir.jl\"\n      ],\n      \"env\": {}\n    }\n  }\n}","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"For each server entry:","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"\"time\", \"mcp_tools_example\": Unique identifiers for your servers\n\"command\": The command to run (should be \"julia\")\n\"args\": Array of arguments, typically the path to your server script\n\"env\": Optional environment variables (can be empty {})","category":"page"},{"location":"claude/#Applying-Changes","page":"Claude Integration","title":"Applying Changes","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"For configuration changes to take effect:","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Save the configuration file\nClose all running Claude processes:\nOn Windows: Use Task Manager to end all Claude processes\nOn macOS: Quit the application\nRestart the Claude Desktop application","category":"page"},{"location":"claude/#Using-Your-MCP-Server","page":"Claude Integration","title":"Using Your MCP Server","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Once configured, you can tell Claude to use your MCP server:","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Please connect to the MCP server named \"time\" and tell me the current time.","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Claude will connect to your server, discover available tools and resources, and use them to fulfill your requests.","category":"page"},{"location":"claude/#Troubleshooting","page":"Claude Integration","title":"Troubleshooting","text":"","category":"section"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"If Claude cannot connect to your server:","category":"page"},{"location":"claude/","page":"Claude Integration","title":"Claude Integration","text":"Check the server name matches exactly what's in your configuration\nVerify the path to your script is correct and accessible\nCheck that your script has all required dependencies installed and precompiled\nLook for any error messages in the Claude Desktop console (Developer Tools)","category":"page"},{"location":"#ModelContextProtocol.jl","page":"Home","title":"ModelContextProtocol.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelContextProtocol.jl is a Julia implementation of the Model Context Protocol (MCP), enabling integration with Large Language Models (LLMs) like Anthropic's Claude.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Model Context Protocol provides a standardized way for applications to offer context and capabilities to LLMs. This package implements the full MCP specification, with mcp_server() as the main entry point.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelContextProtocol\")","category":"page"},{"location":"#Key-Components","page":"Home","title":"Key Components","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides three main types that can be registered with an MCP server:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tools: Callable functions that LLMs can use\nResources: Data sources that LLMs can read\nPrompts: Template-based messages","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Direct-Component-Registration","page":"Home","title":"Direct Component Registration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest way to create an MCP server is to directly register components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModelContextProtocol\nusing JSON3, Dates\n\n# Create a simple tool that returns the current time\ntime_tool = MCPTool(\n    name = \"get_time\",\n    description = \"Get current time in specified format\",\n    parameters = [\n        ToolParameter(\n            name = \"format\",\n            type = \"string\",\n            description = \"DateTime format string\",\n            required = true\n        )\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\"time\" => Dates.format(now(), params[\"format\"])))\n    )\n)\n\n# Create and start server\nserver = mcp_server(\n    name = \"time-server\",\n    description = \"Simple MCP server with time tool\",\n    tools = time_tool\n)\n\nstart!(server)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Creates a tool that returns the current time in a specified format\nRegisters this tool with a new MCP server\nStarts the server process, listening for incoming connections","category":"page"},{"location":"","page":"Home","title":"Home","text":"When Claude connects to this server, it can discover and use the get_time tool to provide formatted time information.","category":"page"},{"location":"#Directory-Based-Organization","page":"Home","title":"Directory-Based Organization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For larger projects, you can organize components in a directory structure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"my_mcp_project/\n├── tools/\n│   ├── time_tool.jl\n│   └── calculator_tool.jl\n├── resources/\n│   └── weather_data.jl\n└── prompts/\n    └── greeting.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each file exports one or more components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# tools/time_tool.jl\nusing ModelContextProtocol\nusing JSON3, Dates\n\ntime_tool = MCPTool(\n    name = \"get_time\",\n    description = \"Get current time in specified format\",\n    parameters = [\n        ToolParameter(name = \"format\", type = \"string\", required = true)\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\"time\" => Dates.format(now(), params[\"format\"])))\n    )\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then auto-register all components at once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModelContextProtocol\n\nserver = mcp_server(\n    name = \"full-server\",\n    description = \"MCP server with auto-registered components\",\n    auto_register_dir = \"my_mcp_project\"  # Directory to scan for components\n)\n\nstart!(server)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The directory approach offers several advantages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Better organization for complex servers\nSeparation of concerns for different components\nAbility to add/modify components without changing server code","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Tools, Resources, and Prompts sections for more details.","category":"page"},{"location":"tools/#MCP-Tools","page":"Tools","title":"MCP Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Tools represent callable functions that language models can invoke. Each tool has a name, description, parameters, and a handler function.","category":"page"},{"location":"tools/#Tool-Structure","page":"Tools","title":"Tool Structure","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Every tool in ModelContextProtocol.jl is represented by the MCPTool struct, which contains:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"name: Unique identifier for the tool\ndescription: Human-readable explanation of the tool's purpose\nparameters: List of input parameters the tool accepts\nhandler: Function that executes when the tool is called\nreturn_type: The type of content the tool returns (defaults to TextContent)","category":"page"},{"location":"tools/#Creating-Tools","page":"Tools","title":"Creating Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Here's how to create a basic tool:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"calculator_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Perform basic arithmetic\",\n    parameters = [\n        ToolParameter(\n            name = \"expression\",\n            type = \"string\",\n            description = \"Math expression to evaluate\",\n            required = true\n        )\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\n            \"result\" => eval(Meta.parse(params[\"expression\"]))\n        ))\n    )\n)","category":"page"},{"location":"tools/#Parameters","page":"Tools","title":"Parameters","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Tool parameters are defined using the ToolParameter struct:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"name: Parameter identifier\ndescription: Explanation of the parameter\ntype: JSON schema type (e.g., \"string\", \"number\", \"boolean\")\nrequired: Whether the parameter must be provided (default: false)","category":"page"},{"location":"tools/#Return-Values","page":"Tools","title":"Return Values","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Tools must return one of the following content types:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"TextContent: For text-based responses\nImageContent: For binary image data","category":"page"},{"location":"tools/#Registering-Tools","page":"Tools","title":"Registering Tools","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Tools can be registered with a server in two ways:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"During server creation:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"server = mcp_server(\n    name = \"my-server\",\n    tools = my_tool  # Single tool or vector of tools\n)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"After server creation:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"register!(server, my_tool)","category":"page"},{"location":"tools/#Directory-Based-Organization","page":"Tools","title":"Directory-Based Organization","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Tools can be organized in directory structures and auto-registered:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"my_server/\n└── tools/\n    ├── calculator.jl\n    └── time_tool.jl","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Each file should export one or more MCPTool instances:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"# calculator.jl\nusing ModelContextProtocol\nusing JSON3\n\ncalculator_tool = MCPTool(\n    name = \"calculate\",\n    description = \"Basic calculator\",\n    parameters = [\n        ToolParameter(name = \"expression\", type = \"string\", required = true)\n    ],\n    handler = params -> TextContent(\n        text = JSON3.write(Dict(\"result\" => eval(Meta.parse(params[\"expression\"]))))\n    )\n)","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Then auto-register from the directory:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"server = mcp_server(\n    name = \"my-server\",\n    auto_register_dir = \"my_server\"\n)","category":"page"}]
}
